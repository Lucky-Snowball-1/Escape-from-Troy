<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Escape from Troy — Mythic Build</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      margin: 0;
      background: #1b1b2a;
      color: #e8d7a1;
      font-family: sans-serif;
    }
    #hud {
      display: flex;
      justify-content: space-between;
      padding: 10px;
      background: #222;
      color: #fff;
      font-weight: bold;
      align-items: center;
      gap: 12px;
    }
    #canvas {
      display: block;
      margin: 0 auto;
      border: 2px solid #444;
      background: #0b0e1a;
    }
    #msg {
      text-align: center;
      margin-top: 6px;
      font-size: 1.1em;
      font-weight: bold;
      min-height: 24px;
    }
    #equipHUD {
      text-align: center;
      color: #fff;
      margin-top: 4px;
      font-weight: bold;
      font-size: 0.95em;
    }

    /* HP bar */
    #hpContainer {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #hpBarOuter {
      width: 160px;
      height: 14px;
      border: 1px solid #555;
      background: #111;
      box-sizing: border-box;
    }
    #hpBarInner {
      height: 100%;
      width: 100%;
      background: #00c853;
      transition: none;
    }
    #hpText {
      min-width: 60px;
      text-align: left;
      font-size: 0.9em;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div>Level: <span id="level">0</span>/35</div>

    <div id="hpContainer">
      <span>HP:</span>
      <span id="hpBarOuter">
        <span id="hpBarInner"></span>
      </span>
      <span id="hpText">100 HP</span>
    </div>

    <div>Time: <span id="time">0.0</span>s</div>
    <div>Difficulty: <span id="difficultyLabel">Medium</span></div>
  </div>

  <canvas id="canvas" width="960" height="540"></canvas>
  <div id="equipHUD">Weapon: None | Helmet: None | Shield: None | Charm: None</div>
  <div id="msg"></div>

<script>
/* =========================================================
   Core constants & global state
   ========================================================= */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;

const W = canvas.width;
const H = canvas.height;

const groundY = H - 80;
const seaY = H - 120;

let keys = {};
let last = performance.now();
let t = 0;

let currentLevel = 0;
let gameState = "playing"; // "playing" | "inventory" | "ended"
let levelJumpUsed = false;
let damageCooldown = 0;
let deathLock = false;
let lastBossBeaten = 0;
let levelComplete = false;
let atSea = false;
let finalVictory = false;

/* =========================================================
   Difficulty & damage scaling
   ========================================================= */
const difficulties = {
  easy:   { name: "Easy",   playerDamage: 1.2, enemyDamage: 0.7 },
  medium: { name: "Medium", playerDamage: 1.0, enemyDamage: 1.0 },
  hard:   { name: "Hard",   playerDamage: 0.8, enemyDamage: 1.3 }
};

let currentDifficulty = "medium";

function setDifficulty(key) {
  if (!difficulties[key]) return;
  currentDifficulty = key;
  const d = difficulties[key];
  document.getElementById("difficultyLabel").textContent = d.name;
  toast("Difficulty set to " + d.name);
}

function scalePlayerDamage(base) {
  const d = difficulties[currentDifficulty] || difficulties.medium;
  return base * d.playerDamage;
}

function scaleEnemyDamage(base) {
  const d = difficulties[currentDifficulty] || difficulties.medium;
  return base * d.enemyDamage;
}

/* =========================================================
   Player
   ========================================================= */
const player = {
  x: 40,
  y: groundY - 32,
  w: 24,
  h: 32,
  vx: 0,
  vy: 0,
  speed: 230,
  jump: 440,
  onGround: true,

  maxHp: 100,
  hp: 100,

  isRolling: false,
  rollTimer: 0,
  rollCooldown: 0,
  rollDir: 0
};

/* =========================================================
   HP HUD helpers
   ========================================================= */
function updateHPHUD() {
  const hpBarInner = document.getElementById("hpBarInner");
  const hpText = document.getElementById("hpText");

  const ratio = Math.max(0, Math.min(1, player.hp / player.maxHp));
  const percent = Math.round(ratio * 100);

  hpBarInner.style.width = (ratio * 100) + "%";

  if (percent >= 70) {
    hpBarInner.style.background = "#00c853";
  } else if (percent >= 30) {
    hpBarInner.style.background = "#ffd600";
  } else {
    hpBarInner.style.background = "#d50000";
  }

  hpText.textContent = `${Math.max(0, Math.round(player.hp))} HP`;
}

/* =========================================================
   Images
   ========================================================= */
const aeneasImg = new Image();
aeneasImg.src = "aeneas.png";

const boatImg = new Image();
boatImg.src = "boat.png";

const greekShipImg = new Image();
greekShipImg.src = "greekship.png";

const waveImg = new Image();
let waveImgLoaded = false;
waveImg.src = "wave.png";
waveImg.onload = () => { waveImgLoaded = true; };

const bossImageSources = {
  "Menelaus": "menelaus.png",
  "Agamemnon": "agamemnon.png",
  "Diomedes": "diomedes.png",
  "Ajax": "ajax.png",
  "Achilles": "achilles.png",
  "Trojan Horse": "trojanhorse.png"
};

const bossImages = {};
for (const name in bossImageSources) {
  const img = new Image();
  img.src = bossImageSources[name];
  bossImages[name] = img;
}

/* =========================================================
   Item data, icons & inventory
   ========================================================= */
const itemData = {
  sword:        { id: "sword",        name: "Sword",              type: "weapon", slot: "weapon" },
  axe:          { id: "axe",          name: "Axe",                type: "weapon", slot: "weapon" },
  bow:          { id: "bow",          name: "Bow",                type: "weapon", slot: "weapon" },
  artemisBow:   { id: "artemisBow",   name: "Artemis's Bow",      type: "weapon", slot: "weapon" },
  spear:        { id: "spear",        name: "Spear",              type: "weapon", slot: "weapon" },
  trident:      { id: "trident",      name: "Trident",            type: "weapon", slot: "weapon" },
  lightning:    { id: "lightning",    name: "Lightning Bolt",     type: "weapon", slot: "weapon" },
  torch:        { id: "torch",        name: "Torch",              type: "weapon", slot: "weapon" },
  shield_item:  { id: "shield_item",  name: "Shield",             type: "shield", slot: "shield" },
  helmet_invisibility: { id: "helmet_invisibility", name: "Helmet of Invisibility", type: "helmet", slot: "helmet" },
  chaos_charm:  { id: "chaos_charm",  name: "Chaos Charm",        type: "charm",  slot: "charm" },
  blood_charm:  { id: "blood_charm",  name: "Blood Charm",        type: "charm",  slot: "charm" },

  time_skip_charm:   { id: "time_skip_charm",   name: "Time Skip Charm",   type: "charm", slot: "charm" },
  time_slow_charm:   { id: "time_slow_charm",   name: "Time Slow Charm",   type: "charm", slot: "charm" },
  time_rewind_charm: { id: "time_rewind_charm", name: "Time Rewind Charm", type: "charm", slot: "charm" },
  time_freeze_charm: { id: "time_freeze_charm", name: "Time Freeze Charm", type: "charm", slot: "charm" },
  fate_charm:        { id: "fate_charm",        name: "Fate Charm",        type: "charm", slot: "charm" }
};

const itemImages = {};
const itemImageFiles = {
  helmet_invisibility: "icons/helmet.png",
  sword: "icons/sword.png",
  axe: "icons/axe.png",
  bow: "icons/bow.png",
  artemisBow: "icons/artemisbow.png",
  spear: "icons/spear.png",
  trident: "icons/trident.png",
  lightning: "icons/lightning.png",
  torch: "icons/torch.png",
  shield_item: "icons/shield.png",
  chaos_charm: "icons/chaos.png",
  blood_charm: "icons/blood.png",

  time_skip_charm:   "icons/time_skip.png",
  time_slow_charm:   "icons/time_slow.png",
  time_rewind_charm: "icons/time_rewind.png",
  time_freeze_charm: "icons/time_freeze.png",
  fate_charm:        "icons/fate.png"
};

for (const id in itemImageFiles) {
  const img = new Image();
  img.src = itemImageFiles[id];
  itemImages[id] = img;
}

// Inventory grid (simple 4x4)
const inventory = []; // {id}
const INVENTORY_COLS = 4;
const INVENTORY_ROWS = 4;

// Equipment slots
const equipment = {
  weapon: null,
  helmet: null,
  shield: null,
  charm: null
};

// Inventory UI layout
const invUI = {
  x: W / 2 - 260,
  y: H / 2 - 160,
  w: 520,
  h: 320,
  cellSize: 56,
  padding: 16
};

// Drag state
let draggingItem = null;
let dragOffsetX = 0;
let dragOffsetY = 0;
let mouseX = 0;
let mouseY = 0;

/* =========================================================
   Weapons, gear & combat
   ========================================================= */
const weapons = {
  sword: {
    type: "melee",
    name: "Sword",
    damage: 1,
    range: 30
  },
  axe: {
    type: "melee",
    name: "Axe",
    damage: 2,
    range: 35
  },
  bow: {
    type: "projectile",
    name: "Bow",
    damage: 1,
    projectileSpeed: 400
  },
  artemisBow: {
    type: "projectile",
    name: "Artemis's Bow",
    damage: 2,
    projectileSpeed: 520,
    homing: true,
    rainArrows: 7,
    rainSpread: 260,
    rainFallSpeed: 500
  },
  spear: {
    type: "hybrid",
    name: "Spear",
    meleeDamage: 1,
    meleeRange: 60,
    throwDamage: 1,
    throwSpeed: 350
  },
  trident: {
    type: "hybrid",
    name: "Trident",
    meleeDamage: 2,
    meleeRange: 50,
    throwDamage: 2,
    throwSpeed: 300,
    waveDamageMultiplier: 3
  },
  lightning: {
    type: "hybrid",
    name: "Lightning Bolt",
    meleeDamage: 2,
    meleeRange: 40,
    throwDamage: 3,
    throwSpeed: 500,
    stormDamage: 3
  },
  torch: {
    type: "hybrid",
    name: "Torch",
    meleeDamage: 1,
    meleeRange: 35,
    throwDamage: 2,
    throwSpeed: 380,
    burnDamage: 1
  }
};

let weaponsOwned = {
  sword: true,
  axe: false,
  bow: false,
  artemisBow: false,
  spear: false,
  trident: false,
  shield: false,
  lightning: false,
  torch: false
};

// Gear
let gearOwned = {
  helmet: false
};

let currentWeapon = "sword";
let shieldActive = false;
let helmetActive = false;
let helmetCooldownRounds = 0;

let projectiles = [];
let waves = [];
let lightningStrikes = [];
let infernos = [];
let specialCooldown = 0;

/* =========================================================
   Allies
   ========================================================= */
let allies = []; // each ally has type + behavior

/* =========================================================
   Weapon drop system
   ========================================================= */
let weaponDrops = [];

const weaponDropChances = {
  bow: 80,
  artemisBow: 35,
  shield: 70,
  axe: 60,
  spear: 50,
  trident: 40,
  lightning: 40,
  torch: 40,
  helmet: 40,
  chaos_charm: 30,
  blood_charm: 30,
  time_skip_charm: 25,
  time_slow_charm: 25,
  time_rewind_charm: 25,
  time_freeze_charm: 25,
  fate_charm: 20
};

function getRandomWeaponToDrop() {
  const candidates = [];
  for (const w of [
    "bow",
    "artemisBow",
    "shield",
    "axe",
    "spear",
    "trident",
    "lightning",
    "torch",
    "helmet",
    "chaos_charm",
    "blood_charm",
    "time_skip_charm",
    "time_slow_charm",
    "time_rewind_charm",
    "time_freeze_charm",
    "fate_charm"
  ]) {
    if (w === "helmet") {
      if (!gearOwned.helmet) candidates.push(w);
    } else if (w === "artemisBow") {
      if (!weaponsOwned.artemisBow) candidates.push(w);
    } else if (
      w === "chaos_charm" ||
      w === "blood_charm" ||
      w === "time_skip_charm" ||
      w === "time_slow_charm" ||
      w === "time_rewind_charm" ||
      w === "time_freeze_charm" ||
      w === "fate_charm"
    ) {
      const already = inventory.some(it => it && it.id === w);
      if (!already) candidates.push(w);
    } else {
      if (!weaponsOwned[w]) candidates.push(w);
    }
  }
  if (candidates.length === 0) return null;

  for (const w of candidates) {
    const chance = weaponDropChances[w] || 0;
    if (Math.random() * 100 < chance) {
      return w;
    }
  }
  return null;
}

function spawnWeaponDrop(x, y, weaponKey) {
  const cx = Math.max(20, Math.min(W - 40, x));
  const cy = Math.max(20, Math.min(H - 40, y));
  weaponDrops.push({
    x: cx,
    y: cy,
    w: 24,
    h: 24,
    weaponKey
  });
}

function maybeSpawnWeaponDropAt(x, y) {
  const w = getRandomWeaponToDrop();
  if (w) spawnWeaponDrop(x, y, w);
}

/* =========================================================
   Helpers
   ========================================================= */
function isBossLevel(n) {
  return bossDefs[n] !== undefined;
}

function collides(a, b) {
  return (
    a.x < b.x + b.w &&
    a.x + a.w > b.x &&
    a.y < b.y + b.h &&
    a.y + a.h > b.y
  );
}

/* =========================================================
   Player movement & physics
   ========================================================= */
function updatePlayer(dt) {
  let move = 0;
  if (keys["arrowleft"] || keys["a"]) move -= 1;
  if (keys["arrowright"] || keys["d"]) move += 1;

  player.vx = move * player.speed;

  if ((keys["arrowup"] || keys["w"]) && player.onGround) {
    player.vy = -player.jump;
    player.onGround = false;
  }

  if (!player.onGround) {
    player.vy += 900 * dt;
  }

  player.x += player.vx * dt;
  player.y += player.vy * dt;

  if (!atSea) {
    if (player.y + player.h >= groundY) {
      player.y = groundY - player.h;
      player.vy = 0;
      player.onGround = true;
    }
  }

  if (player.isRolling) {
    player.rollTimer -= dt;
    if (player.rollTimer <= 0) {
      player.isRolling = false;
      player.h = 32;
    } else {
      player.h = 20;
      player.y = groundY - player.h;
      player.x += player.rollDir * 260 * dt;
    }
  }

  if (player.rollCooldown > 0) {
    player.rollCooldown -= dt;
  }
}

/* =========================================================
   Basic attack (Space)
   ========================================================= */
function playerAttack() {
  const weapon = weapons[currentWeapon];
  if (!weapon) return;

  if (weapon.type === "melee") {
    const dmg = scalePlayerDamage(weapon.damage);
    const range = weapon.range;

    const hitbox = {
      x: player.x + player.w,
      y: player.y,
      w: range,
      h: player.h
    };

    if (boss && collides(hitbox, boss)) {
      boss.hp -= dmg;
      toast("Hit " + boss.name + "!");
      if (boss.hp <= 0) {
        toast(boss.name + " defeated!");
        lastBossBeaten = currentLevel;
        maybeSpawnWeaponDropAt(boss.x + boss.w / 2, boss.y);
        boss = null;
      }
    }
  }

  if (weapon.type === "projectile") {
    const px = player.x + player.w;
    const py = player.y + player.h / 2;
    const dmg = scalePlayerDamage(weapon.damage);

    projectiles.push({
      x: px,
      y: py,
      w: 18,
      h: 6,
      vx: weapon.projectileSpeed,
      vy: 0,
      damage: dmg,
      type: weapon.homing ? "artemisArrow" : "arrow"
    });

    toast(weapon.homing ? "Homing arrow fired!" : "Arrow loosed!");
  }
}

/* =========================================================
   J: Special Melee (20 HP base)
   ========================================================= */
function specialMelee() {
  if (specialCooldown > 0) {
    toast("Special cooling down...");
    return;
  }

  specialCooldown = 0.6;

  const base = 20;
  const dmg = scalePlayerDamage(base);

  let range = 40;

  if (currentWeapon === "spear" && weaponsOwned.spear) {
    range = weapons.spear.meleeRange + 20;
    toast("Spear jab!");
  } else if (currentWeapon === "trident" && weaponsOwned.trident) {
    range = weapons.trident.meleeRange + 20;
    toast("Trident stab!");
  } else if (currentWeapon === "axe" && weaponsOwned.axe) {
    range = weapons.axe.range + 10;
    toast("Heavy swing!");
  } else if (currentWeapon === "lightning" && weaponsOwned.lightning) {
    range = weapons.lightning.meleeRange + 20;
    toast("Charged lightning stab!");
  } else if (currentWeapon === "torch" && weaponsOwned.torch) {
    range = weapons.torch.meleeRange + 10;
    toast("Fiery smash!");
  } else {
    toast("Strong strike!");
  }

  const hitbox = {
    x: player.x + player.w,
    y: player.y,
    w: range,
    h: player.h
  };

  if (boss && collides(hitbox, boss)) {
    boss.hp -= dmg;
    toast("Critical hit on " + boss.name + "!");
    if (boss.hp <= 0) {
      toast(boss.name + " defeated!");
      lastBossBeaten = currentLevel;
      maybeSpawnWeaponDropAt(boss.x + boss.w / 2, boss.y);
      boss = null;
    }
  }

  if (currentLevel === 35 && greekShips.length > 0) {
    for (let i = greekShips.length - 1; i >= 0; i--) {
      const ship = greekShips[i];
      const shipBox = {
        x: ship.x,
        y: ship.y - ship.h,
        w: ship.w,
        h: ship.h
      };
      if (collides(hitbox, shipBox)) {
        ship.hp -= dmg;
        toast("Massive hit on Greek ship!");
        if (ship.hp <= 0) {
          maybeSpawnWeaponDropAt(ship.x + ship.w / 2, ship.y - ship.h);
          greekShips.splice(i, 1);
        }
      }
    }
  }
}

/* =========================================================
   K: Special Throw (15 HP base)
   ========================================================= */
function specialThrow() {
  if (specialCooldown > 0) {
    toast("Special cooling down...");
    return;
  }

  specialCooldown = 0.8;

  const dmg = scalePlayerDamage(15);
  const px = player.x + player.w;
  const py = player.y + player.h / 2;

  if (currentWeapon === "spear" && weaponsOwned.spear) {
    spawnProjectile(px, py, weapons.spear.throwSpeed, dmg, "spear");
    toast("Spear thrown!");
  } else if (currentWeapon === "trident" && weaponsOwned.trident) {
    spawnProjectile(px, py, weapons.trident.throwSpeed, dmg, "trident");
    toast("Trident hurled!");
  } else if (currentWeapon === "lightning" && weaponsOwned.lightning) {
    spawnProjectile(px, py, weapons.lightning.throwSpeed, dmg, "lightning");
    toast("Lightning bolt thrown!");
  } else if (currentWeapon === "torch" && weaponsOwned.torch) {
    spawnProjectile(px, py, weapons.torch.throwSpeed, dmg, "flame");
    toast("Flame hurled!");
  } else if (currentWeapon === "artemisBow" && weaponsOwned.artemisBow) {
    projectiles.push({
      x: px,
      y: py,
      w: 20,
      h: 6,
      vx: weapons.artemisBow.projectileSpeed,
      vy: 0,
      damage: dmg,
      type: "artemisArrow"
    });
    toast("Homing arrow hurled!");
  } else if (weaponsOwned.bow) {
    spawnProjectile(px, py, weapons.bow.projectileSpeed, dmg, "arrow");
    toast("Arrow loosed!");
  }
}

/* =========================================================
   L: Weapon Ultimate Specials (30 HP base)
   ========================================================= */
function specialUltimate() {
  if (specialCooldown > 0) {
    toast("Special cooling down...");
    return;
  }

  specialCooldown = 1.2;

  const dmg = scalePlayerDamage(30);

  if (currentWeapon === "trident" && weaponsOwned.trident) {
    summonWave(dmg);
  } else if (currentWeapon === "lightning" && weaponsOwned.lightning) {
    summonLightningStorm(dmg);
  } else if (currentWeapon === "torch" && weaponsOwned.torch) {
    summonInferno(dmg);
  } else if (currentWeapon === "artemisBow" && weaponsOwned.artemisBow) {
    summonRainOfArrows(dmg);
  } else {
    toast("No special power for this weapon");
  }
}

/* =========================================================
   Projectile spawner
   ========================================================= */
function spawnProjectile(x, y, speed, damage, type) {
  projectiles.push({
    x,
    y,
    w: 18,
    h: 6,
    vx: speed,
    vy: 0,
    damage,
    type
  });
}

/* =========================================================
   Time powers & Time Charms
   ========================================================= */
let timeSlowActive = false;
let timeSlowTimer = 0;

let timeFreezeActive = false;
let timeFreezeTimer = 0;

let timeCharmUsedThisLevel = false;
let lastFateUseLevel = -999;

function canUseTimeCharm() {
  if (!equipment.charm) {
    toast("No charm equipped.");
    return false;
  }
  if (timeCharmUsedThisLevel) {
    toast("Charm already used this level.");
    return false;
  }
  if (gameState !== "playing") return false;
  return true;
}

function useEquippedTimeCharm() {
  if (!canUseTimeCharm()) return;

  const id = equipment.charm;

  if (id === "time_skip_charm") {
    useTimeSkipCharm();
  } else if (id === "time_slow_charm") {
    useTimeSlowCharm();
  } else if (id === "time_rewind_charm") {
    useTimeRewindCharm();
  } else if (id === "time_freeze_charm") {
    useTimeFreezeCharm();
  } else if (id === "fate_charm") {
    useFateCharm();
  } else {
    toast("This charm has no time power.");
    return;
  }

  timeCharmUsedThisLevel = true;
}

function useTimeSkipCharm() {
  if (currentLevel >= 35) {
    toast("Time cannot skip the final fate...");
    return;
  }
  if (isBossLevel(currentLevel) || isBossLevel(currentLevel + 1)) {
    toast("Time cannot skip a boss battle.");
    return;
  }
  toast("Time bends—skipping ahead!");
  levelComplete = true;
  setTimeout(() => startLevel(currentLevel + 1), 400);
}

function useTimeSlowCharm() {
  if (timeSlowActive) {
    toast("Time is already slowed...");
    return;
  }
  timeSlowActive = true;
  timeSlowTimer = 5;
  toast("Time slows around you...");
}

function useTimeRewindCharm() {
  const heal = player.maxHp * 0.3;
  player.hp = Math.min(player.maxHp, player.hp + heal);
  updateHPHUD();
  toast("Time rewinds your wounds...");
}

function useTimeFreezeCharm() {
  if (timeFreezeActive) {
    toast("Time is already frozen...");
    return;
  }
  timeFreezeActive = true;
  timeFreezeTimer = 3;
  toast("Time freezes in place...");
}

function useFateCharm() {
  if (currentLevel >= 35) {
    toast("Fate cannot change the final battle.");
    return;
  }
  if (isBossLevel(currentLevel) || isBossLevel(currentLevel + 1)) {
    toast("Fate cannot skip a boss battle.");
    return;
  }
  if (currentLevel - lastFateUseLevel < 3) {
    toast("Fate can only be changed every 3 levels.");
    return;
  }

  toast("Fate shifts—your path jumps ahead!");
  lastFateUseLevel = currentLevel;
  levelComplete = true;
  setTimeout(() => startLevel(currentLevel + 1), 400);
}

/* =========================================================
   Controls
   ========================================================= */
addEventListener("keydown", e => {
  const k = e.key.toLowerCase();
  keys[k] = true;

  // Difficulty hotkeys
  if (e.key === "F1") setDifficulty("easy");
  if (e.key === "F2") setDifficulty("medium");
  if (e.key === "F3") setDifficulty("hard");

  if (gameState === "inventory") {
    if (k === "i") closeInventory();
    if (e.key === "9") unlockAll();
    return;
  }

  // Attacks
  if (e.key === " " || e.key === "Spacebar") playerAttack();
  if (k === "j") specialMelee();
  if (k === "k") specialThrow();
  if (k === "l") specialUltimate();

  // Rolling
  if (k === "arrowdown" && !player.isRolling && player.rollCooldown <= 0) {
    let dir = 0;
    if (keys["arrowleft"] || keys["a"]) dir = -1;
    if (keys["arrowright"] || keys["d"]) dir = 1;

    player.isRolling = true;
    player.rollTimer = 0.35;
    player.rollCooldown = 0.8;
    player.rollDir = dir;
    toast(dir === 0 ? "Crouch roll!" : dir < 0 ? "Roll left!" : "Roll right!");
  }

  // Weapon selection
  if (k === "q" && weaponsOwned.sword) equipWeapon("sword");
  if (k === "w" && weaponsOwned.axe) equipWeapon("axe");
  if (k === "e" && (weaponsOwned.bow || weaponsOwned.artemisBow)) {
    equipWeapon(weaponsOwned.artemisBow ? "artemisBow" : "bow");
  }
  if (k === "r" && weaponsOwned.spear) equipWeapon("spear");
  if (k === "t" && weaponsOwned.trident) equipWeapon("trident");
  if (k === "z" && weaponsOwned.lightning) equipWeapon("lightning");
  if (k === "v" && weaponsOwned.torch) equipWeapon("torch");

  // Shield toggle
  if (k === "y" && weaponsOwned.shield) {
    shieldActive = !shieldActive;
    equipment.shield = shieldActive ? "shield_item" : null;
    updateEquipHUD();
    toast(shieldActive ? "Shield equipped" : "Shield removed");
  }

  // Helmet of invisibility
  if (k === "x" && gearOwned.helmet) {
    if (helmetActive) {
      toast("Helmet already active this round");
    } else if (helmetCooldownRounds > 0) {
      toast("Helmet recharging: " + helmetCooldownRounds + " rounds left");
    } else {
      helmetActive = true;
      helmetCooldownRounds = 2;
      equipment.helmet = "helmet_invisibility";
      updateEquipHUD();
      toast("You vanish from sight...");
    }
  }

  // Inventory
  if (k === "i") openInventory();

  // Cheat
  if (e.key === "9") unlockAll();

  // Level jumps
  const num = parseInt(e.key);
  if (!isNaN(num)) {
    if (num >= 1 && num <= 6) {
      const target = num * 5;
      levelJumpUsed = true;
      toast("Jumped to boss level " + target);
      startLevel(target);
    } else if (num === 7) {
      levelJumpUsed = true;
      toast("Jumped to final battle (35)");
      startLevel(35);
    }
  }

  // Time Charm activation (H)
  if (k === "h" && gameState === "playing") {
    useEquippedTimeCharm();
  }
});

addEventListener("keyup", e => {
  keys[e.key.toLowerCase()] = false;
});

/* =========================================================
   Equip helper
   ========================================================= */
function equipWeapon(key) {
  currentWeapon = key;
  equipment.weapon = key;
  updateEquipHUD();
  toast(itemData[key].name + " equipped");
}

/* =========================================================
   Projectile updates (arrows, flames, lightning, etc.)
   ========================================================= */
function updateHomingArrow(p, dt) {
  if (!boss) return;

  const targetX = boss.x + boss.w / 2;
  const targetY = boss.y + boss.h / 2;

  const dx = targetX - p.x;
  const dy = targetY - p.y;
  const dist = Math.hypot(dx, dy);

  if (dist > 0) {
    const speed = 260;
    p.vx = (dx / dist) * speed;
    p.vy = (dy / dist) * speed;
  }
}

/* =========================================================
   Giant Wave (Trident Ultimate)
   ========================================================= */
function summonWave(dmg) {
  const wave = {
    x: player.x + player.w,
    y: H / 2,
    w: 40,
    h: 40,
    vx: 260,
    growthRateW: 180,
    growthRateH: 140,
    maxHeight: 260,
    alive: true,
    damage: dmg * 3
  };

  waves.push(wave);
  toast("A mighty wave surges forward!");
}

/* =========================================================
   Lightning Storm (Lightning Ultimate)
   ========================================================= */
function summonLightningStorm(dmg) {
  for (let i = 0; i < 6; i++) {
    const x = Math.random() * (W - 40);
    lightningStrikes.push({
      x,
      y: 0,
      w: 20,
      h: H,
      life: 0.35,
      damage: dmg * 1.5
    });
  }
  toast("Lightning storm unleashed!");
}

/* =========================================================
   Inferno (Torch Ultimate)
   ========================================================= */
function summonInferno(dmg) {
  infernos.push({
    x: player.x + player.w + 40,
    y: player.y + player.h / 2,
    radius: 10,
    maxRadius: 160,
    growthRate: 180,
    alive: true,
    damage: dmg * 1.2
  });

  toast("Inferno ignited!");
}

/* =========================================================
   Rain of Arrows (Artemis Bow Ultimate)
   ========================================================= */
function summonRainOfArrows(dmg) {
  const count = 7;
  const spread = 260;

  for (let i = 0; i < count; i++) {
    const offset = (Math.random() - 0.5) * spread;
    projectiles.push({
      x: player.x + player.w + offset,
      y: -20,
      w: 12,
      h: 20,
      vx: 0,
      vy: 500,
      damage: dmg,
      type: "arrow"
    });
  }

  toast("Artemis rains arrows from above!");
}

/* =========================================================
   Projectile update loop (boss + ships hit detection)
   ========================================================= */
function updateProjectiles(dt) {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];

    if (p.type === "artemisArrow") {
      updateHomingArrow(p, dt);
    }

    p.x += p.vx * dt;
    if (p.vy !== undefined) p.y += p.vy * dt;

    if (p.x > W || p.x + p.w < 0 || p.y > H) {
      projectiles.splice(i, 1);
      continue;
    }

    if (boss && collides(p, boss)) {
      boss.hp -= p.damage;
      toast("Projectile hit " + boss.name + "!");
      projectiles.splice(i, 1);

      if (boss.hp <= 0) {
        toast(boss.name + " defeated!");
        lastBossBeaten = currentLevel;
        maybeSpawnWeaponDropAt(boss.x + boss.w / 2, boss.y);
        boss = null;
      }
      continue;
    }

    if (currentLevel === 35 && greekShips.length > 0) {
      let hitShip = false;

      for (let j = greekShips.length - 1; j >= 0; j--) {
        const ship = greekShips[j];
        const shipBox = {
          x: ship.x,
          y: ship.y - ship.h,
          w: ship.w,
          h: ship.h
        };

        if (collides(p, shipBox)) {
          ship.hp -= p.damage;
          projectiles.splice(i, 1);
          hitShip = true;

          if (ship.hp <= 0) {
            maybeSpawnWeaponDropAt(ship.x + ship.w / 2, ship.y - ship.h);
            greekShips.splice(j, 1);
          }
          break;
        }
      }

      if (hitShip) continue;
    }
  }
}

/* =========================================================
   Wave update loop
   ========================================================= */
function updateWaves(dt) {
  for (let i = waves.length - 1; i >= 0; i--) {
    const wave = waves[i];

    if (!wave.alive) {
      waves.splice(i, 1);
      continue;
    }

    wave.x += wave.vx * dt;
    wave.w += wave.growthRateW * dt;
    wave.h += wave.growthRateH * dt;

    if (wave.h > wave.maxHeight) wave.h = wave.maxHeight;

    const waveCenterY = H / 2;
    wave.y = waveCenterY - wave.h / 2;

    const hitbox = {
      x: wave.x,
      y: wave.y,
      w: wave.w,
      h: wave.h
    };

    if (boss && collides(hitbox, boss)) {
      boss.hp -= wave.damage;
      toast("Wave smashes " + boss.name + "!");

      if (boss.hp <= 0) {
        toast(boss.name + " defeated by the wave!");
        lastBossBeaten = currentLevel;
        maybeSpawnWeaponDropAt(boss.x + boss.w / 2, boss.y);
        boss = null;
      }
    }

    if (currentLevel === 35 && greekShips.length > 0) {
      for (let j = greekShips.length - 1; j >= 0; j--) {
        const ship = greekShips[j];
        const shipBox = {
          x: ship.x,
          y: ship.y - ship.h,
          w: ship.w,
          h: ship.h
        };

        if (collides(hitbox, shipBox)) {
          ship.hp -= wave.damage;

          if (ship.hp <= 0) {
            maybeSpawnWeaponDropAt(ship.x + ship.w / 2, ship.y - ship.h);
            greekShips.splice(j, 1);
          }
        }
      }
    }

    if (wave.x > W && wave.w > W * 1.2) {
      wave.alive = false;
    }
  }
}

/* =========================================================
   Lightning strike update loop
   ========================================================= */
function updateLightning(dt) {
  for (let i = lightningStrikes.length - 1; i >= 0; i--) {
    const strike = lightningStrikes[i];
    strike.life -= dt;

    if (strike.life <= 0) {
      lightningStrikes.splice(i, 1);
      continue;
    }

    const box = {
      x: strike.x,
      y: strike.y,
      w: strike.w,
      h: strike.h
    };

    if (boss && collides(box, boss)) {
      boss.hp -= strike.damage;

      if (boss.hp <= 0) {
        toast(boss.name + " blasted by lightning!");
        lastBossBeaten = currentLevel;
        maybeSpawnWeaponDropAt(boss.x + boss.w / 2, boss.y);
        boss = null;
      }
    }

    if (currentLevel === 35 && greekShips.length > 0) {
      for (let j = greekShips.length - 1; j >= 0; j--) {
        const ship = greekShips[j];
        const shipBox = {
          x: ship.x,
          y: ship.y - ship.h,
          w: ship.w,
          h: ship.h
        };

        if (collides(box, shipBox)) {
          ship.hp -= strike.damage;

          if (ship.hp <= 0) {
            maybeSpawnWeaponDropAt(ship.x + ship.w / 2, ship.y - ship.h);
            greekShips.splice(j, 1);
          }
        }
      }
    }
  }
}

/* =========================================================
   Inferno update loop
   ========================================================= */
function updateInfernos(dt) {
  for (let i = infernos.length - 1; i >= 0; i--) {
    const inf = infernos[i];

    if (!inf.alive) {
      infernos.splice(i, 1);
      continue;
    }

    inf.radius += inf.growthRate * dt;

    if (inf.radius >= inf.maxRadius) {
      inf.alive = false;
    }

    const r2 = inf.radius * inf.radius;

    function inside(obj) {
      const cx = obj.x + obj.w / 2;
      const cy = obj.y + obj.h / 2;
      const dx = cx - inf.x;
      const dy = cy - inf.y;
      return dx * dx + dy * dy <= r2;
    }

    if (boss && inside(boss)) {
      boss.hp -= inf.damage;

      if (boss.hp <= 0) {
        toast(boss.name + " consumed by flames!");
        lastBossBeaten = currentLevel;
        maybeSpawnWeaponDropAt(boss.x + boss.w / 2, boss.y);
        boss = null;
      }
    }

    if (currentLevel === 35 && greekShips.length > 0) {
      for (let j = greekShips.length - 1; j >= 0; j--) {
        const ship = greekShips[j];
        const shipBox = {
          x: ship.x,
          y: ship.y - ship.h,
          w: ship.w,
          h: ship.h
        };

        if (inside(shipBox)) {
          ship.hp -= inf.damage;

          if (ship.hp <= 0) {
            maybeSpawnWeaponDropAt(ship.x + ship.w / 2, ship.y - ship.h);
            greekShips.splice(j, 1);
          }
        }
      }
    }
  }
}

/* =========================================================
   Inventory drawing helpers
   ========================================================= */
function drawItemIcon(id, x, y, size) {
  const img = itemImages[id];

  if (img && img.complete && img.naturalWidth > 0) {
    ctx.drawImage(img, x, y, size, size);
    return;
  }

  ctx.save();
  switch (id) {
    case "helmet_invisibility": ctx.fillStyle = "#bbbbbb"; break;
    case "sword": ctx.fillStyle = "#cccccc"; break;
    case "axe": ctx.fillStyle = "#ff5555"; break;
    case "bow": ctx.fillStyle = "#ffaa00"; break;
    case "artemisBow": ctx.fillStyle = "#dddddd"; break;
    case "spear": ctx.fillStyle = "#ffffff"; break;
    case "trident": ctx.fillStyle = "#55ff55"; break;
    case "lightning": ctx.fillStyle = "#ffff55"; break;
    case "torch": ctx.fillStyle = "#ff8844"; break;
    case "shield_item": ctx.fillStyle = "#88ffff"; break;
    case "chaos_charm": ctx.fillStyle = "#ff00ff"; break;
    case "blood_charm": ctx.fillStyle = "#aa0000"; break;
    case "time_skip_charm": ctx.fillStyle = "#66ccff"; break;
    case "time_slow_charm": ctx.fillStyle = "#6699ff"; break;
    case "time_rewind_charm": ctx.fillStyle = "#cc66ff"; break;
    case "time_freeze_charm": ctx.fillStyle = "#99ffff"; break;
    case "fate_charm": ctx.fillStyle = "#ffcc33"; break;
    default: ctx.fillStyle = "#cccccc"; break;
  }
  ctx.fillRect(x, y, size, size);
  ctx.restore();
}

/* =========================================================
   Inventory UI
   ========================================================= */
function drawInventoryUI() {
  ctx.fillStyle = "rgba(0,0,0,0.7)";
  ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = "#222";
  ctx.fillRect(invUI.x, invUI.y, invUI.w, invUI.h);
  ctx.strokeStyle = "#aaa";
  ctx.lineWidth = 2;
  ctx.strokeRect(invUI.x, invUI.y, invUI.w, invUI.h);

  ctx.fillStyle = "#fff";
  ctx.font = "20px sans-serif";
  ctx.fillText("Inventory (I to close)", invUI.x + 20, invUI.y + 30);

  const slotSize = 56;
  const slotY = invUI.y + invUI.padding + 20;
  const slotXStart = invUI.x + invUI.padding + 40;
  const labels = ["Weapon", "Helmet", "Shield", "Charm"];
  const keysSlots = ["weapon", "helmet", "shield", "charm"];

  ctx.font = "14px sans-serif";
  for (let i = 0; i < keysSlots.length; i++) {
    const sx = slotXStart + i * (slotSize + 40);
    const sy = slotY;

    ctx.strokeStyle = "#888";
    ctx.strokeRect(sx, sy, slotSize, slotSize);

    ctx.fillStyle = "#fff";
    ctx.fillText(labels[i], sx, sy + slotSize + 16);

    const itemId = equipment[keysSlots[i]];
    if (itemId) {
      drawItemIcon(itemId, sx + 4, sy + 4, slotSize - 8);
    }
  }

  const invX = invUI.x + invUI.padding;
  const invY = invUI.y + invUI.padding + 80;

  for (let row = 0; row < INVENTORY_ROWS; row++) {
    for (let col = 0; col < INVENTORY_COLS; col++) {
      const idx = row * INVENTORY_COLS + col;
      const cellX = invX + col * invUI.cellSize;
      const cellY = invY + row * invUI.cellSize;

      ctx.strokeStyle = "#555";
      ctx.strokeRect(cellX, cellY, invUI.cellSize, invUI.cellSize);

      const item = inventory[idx];
      if (item) {
        if (
          draggingItem &&
          draggingItem.source === "inventory" &&
          draggingItem.index === idx
        ) {
          continue;
        }
        drawItemIcon(item.id, cellX + 4, cellY + 4, invUI.cellSize - 8);
      }
    }
  }

  if (draggingItem) {
    const size = 48;
    drawItemIcon(draggingItem.itemId, mouseX - size / 2, mouseY - size / 2, size);
  }
}

/* =========================================================
   Inventory drag & drop
   ========================================================= */
canvas.addEventListener("mousedown", e => {
  if (gameState !== "inventory") return;

  const rect = canvas.getBoundingClientRect();
  mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
  mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);

  const invX = invUI.x + invUI.padding;
  const invY = invUI.y + invUI.padding + 80;

  for (let row = 0; row < INVENTORY_ROWS; row++) {
    for (let col = 0; col < INVENTORY_COLS; col++) {
      const idx = row * INVENTORY_COLS + col;
      const cellX = invX + col * invUI.cellSize;
      const cellY = invY + row * invUI.cellSize;

      if (
        mouseX >= cellX &&
        mouseX <= cellX + invUI.cellSize &&
        mouseY >= cellY &&
        mouseY <= cellY + invUI.cellSize
      ) {
        const item = inventory[idx];
        if (item) {
          draggingItem = {
            source: "inventory",
            index: idx,
            itemId: item.id
          };
          dragOffsetX = mouseX - cellX;
          dragOffsetY = mouseY - cellY;
        }
      }
    }
  }

  const slotSize = 56;
  const slotY = invUI.y + invUI.padding + 20;
  const slotXStart = invUI.x + invUI.padding + 40;
  const slots = ["weapon", "helmet", "shield", "charm"];

  for (let i = 0; i < slots.length; i++) {
    const sx = slotXStart + i * (slotSize + 40);
    const sy = slotY;

    if (
      mouseX >= sx &&
      mouseX <= sx + slotSize &&
      mouseY >= sy &&
      mouseY <= sy + slotSize
    ) {
      const slotKey = slots[i];
      const itemId = equipment[slotKey];

      if (itemId) {
        draggingItem = {
          source: "slot",
          slotKey,
          itemId
        };
        dragOffsetX = mouseX - sx;
        dragOffsetY = mouseY - sy;
      }
    }
  }
});

canvas.addEventListener("mousemove", e => {
  if (gameState !== "inventory") return;

  const rect = canvas.getBoundingClientRect();
  mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
  mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
});

canvas.addEventListener("mouseup", e => {
  if (gameState !== "inventory") return;
  if (!draggingItem) return;

  const rect = canvas.getBoundingClientRect();
  mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
  mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);

  const draggedId = draggingItem.itemId;
  const data = itemData[draggedId];

  let placed = false;

  const slotSize = 56;
  const slotY = invUI.y + invUI.padding + 20;
  const slotXStart = invUI.x + invUI.padding + 40;
  const slots = ["weapon", "helmet", "shield", "charm"];

  for (let i = 0; i < slots.length; i++) {
    const slotKey = slots[i];
    const sx = slotXStart + i * (slotSize + 40);
    const sy = slotY;

    if (
      mouseX >= sx &&
      mouseX <= sx + slotSize &&
      mouseY >= sy &&
      mouseY <= sy + slotSize
    ) {
      if (data && data.slot === slotKey) {
        if (draggingItem.source === "inventory") {
          inventory[draggingItem.index] = null;
        } else if (draggingItem.source === "slot") {
          equipment[draggingItem.slotKey] = null;
        }

        equipment[slotKey] = draggedId;
        applyEquipmentEffects();
        updateEquipHUD();
        placed = true;
      }
    }
  }

  if (!placed) {
    const invX = invUI.x + invUI.padding;
    const invY = invUI.y + invUI.padding + 80;

    for (let row = 0; row < INVENTORY_ROWS; row++) {
      for (let col = 0; col < INVENTORY_COLS; col++) {
        const idx = row * INVENTORY_COLS + col;
        const cellX = invX + col * invUI.cellSize;
        const cellY = invY + row * invUI.cellSize;

        if (
          mouseX >= cellX &&
          mouseX <= cellX + invUI.cellSize &&
          mouseY >= cellY &&
          mouseY <= cellY + invUI.cellSize
        ) {
          if (draggingItem.source === "inventory") {
            const fromIdx = draggingItem.index;
            const temp = inventory[idx];
            inventory[idx] = { id: draggedId };
            inventory[fromIdx] = temp || null;
          } else if (draggingItem.source === "slot") {
            if (!inventory[idx]) {
              inventory[idx] = { id: draggedId };
              equipment[draggingItem.slotKey] = null;
              applyEquipmentEffects();
              updateEquipHUD();
            } else {
              const temp = inventory[idx];
              inventory[idx] = { id: draggedId };
              equipment[draggingItem.slotKey] = temp.id;
              applyEquipmentEffects();
              updateEquipHUD();
            }
          }
          placed = true;
        }
      }
    }
  }

  draggingItem = null;
});

/* =========================================================
   Equipment effects
   ========================================================= */
function applyEquipmentEffects() {
  if (equipment.weapon) {
    currentWeapon = equipment.weapon;
  }

  shieldActive = equipment.shield === "shield_item";

  gearOwned.helmet = !!equipment.helmet;
  helmetActive = equipment.helmet === "helmet_invisibility";
}

/* =========================================================
   Inventory helpers
   ========================================================= */
function addItemToInventory(id) {
  for (let i = 0; i < INVENTORY_ROWS * INVENTORY_COLS; i++) {
    if (!inventory[i]) {
      inventory[i] = { id };
      return;
    }
  }
}

/* =========================================================
   Allies drawing
   ========================================================= */
function drawAllies() {
  allies.forEach(a => {
    if (a.type === "hector") ctx.fillStyle = "#66ff66";
    else if (a.type === "paris") ctx.fillStyle = "#66aaff";
    else if (a.type === "priam") ctx.fillStyle = "#ffcc66";
    else if (a.type === "helen") ctx.fillStyle = "#ff99ff";
    else ctx.fillStyle = "#88ff88";

    ctx.fillRect(a.x, a.y, a.w, a.h);
  });
}

/* =========================================================
   Allies behavior (HP version)
   ========================================================= */
function updateAllies(dt) {
  allies.forEach(a => {
    if (a.type === "hector") {
      if (boss) {
        if (a.x < boss.x - 40) a.x += a.vx * dt;

        const hitbox = { x: a.x, y: a.y, w: a.w, h: a.h };
        if (collides(hitbox, boss)) {
          boss.hp -= 0.5 * dt;
        }
      }

    } else if (a.type === "paris") {
      a.shootTimer -= dt;
      if (a.shootTimer <= 0 && boss) {
        a.shootTimer = 1.2;
        const px = a.x + a.w;
        const py = a.y + a.h / 2;
        spawnProjectile(px, py, 320, scalePlayerDamage(1), "arrow");
      }

    } else if (a.type === "priam") {
      a.healTimer -= dt;
      if (a.healTimer <= 0) {
        a.healTimer = 4;

        if (player.hp < player.maxHp) {
          player.hp = Math.min(player.maxHp, player.hp + 10);
          updateHPHUD();
          toast("Priam restores your strength!");
        }
      }

    } else if (a.type === "helen") {
      const targetX = player.x - 40;
      if (a.x < targetX) a.x += 120 * dt;
      if (a.x > targetX) a.x -= 120 * dt;
      a.y = player.y - 10;
    }
  });
}

/* =========================================================
   Allies spawn logic
   ========================================================= */
function spawnAlliesForLevel() {
  allies = [];

  let count = 0;
  if (currentLevel === 5 || currentLevel === 10) count = 1;
  if (currentLevel === 15 || currentLevel === 20) count = 2;
  if (currentLevel === 25 || currentLevel === 30) count = 3;

  if (count >= 1) {
    allies.push({
      type: "hector",
      x: 120,
      y: groundY - 32,
      w: 24,
      h: 32,
      vx: 140
    });
  }

  if (count >= 2) {
    allies.push({
      type: "paris",
      x: 80,
      y: groundY - 32,
      w: 20,
      h: 28,
      shootTimer: 0
    });
  }

  if (count >= 3) {
    allies.push({
      type: "priam",
      x: 60,
      y: groundY - 32,
      w: 20,
      h: 30,
      healTimer: 0
    });
  }

  if (currentLevel === 30) {
    allies.push({
      type: "helen",
      x: 40,
      y: groundY - 40,
      w: 18,
      h: 26
    });
  }
}

/* =========================================================
   Boss & ship spawning
   ========================================================= */
const bossDefs = {
  5:  { name: "Menelaus",     hp: 6  },
  10: { name: "Agamemnon",    hp: 8  },
  15: { name: "Diomedes",     hp: 10 },
  20: { name: "Ajax",         hp: 12 },
  25: { name: "Achilles",     hp: 15 },
  30: { name: "Trojan Horse", hp: 20 }
};

let boss = null;

function spawnBoss(def) {
  boss = {
    name: def.name,
    hp: def.hp,
    x: W - 200,
    y: groundY - 120,
    w: 100,
    h: 100
  };
}

let boat = null;
let greekShips = [];

function spawnGreekShipsForFinal() {
  greekShips = [];
  const count = 3;

  for (let i = 0; i < count; i++) {
    greekShips.push({
      x: W + i * 180,
      y: seaY + 10,
      w: 140,
      h: 100,
      vx: -120,
      hp: 5
    });
  }
}

/* =========================================================
   Obstacles
   ========================================================= */
let groundObstacles = [];
let fallingObstacles = [];
let lowObstacles = [];

let groundSpawnTimer = 0;
let fallingSpawnTimer = 0;

function spawnGroundObstacle() {
  groundObstacles.push({
    x: W + 40,
    y: atSea ? seaY - 30 : groundY - 30,
    w: 30,
    h: 30,
    speed: 200
  });
}

function spawnFallingObstacle() {
  fallingObstacles.push({
    x: Math.random() * (W - 40),
    y: -40,
    w: 30,
    h: 30,
    vy: 200 + Math.random() * 200
  });
}

function spawnLowObstacle() {
  lowObstacles.push({
    x: W + 40,
    y: groundY - 20,
    w: 40,
    h: 20,
    speed: 200
  });
}

/* =========================================================
   Level start / reset
   ========================================================= */
function startLevel(n) {
  currentLevel = n;
  t = 0;
  gameState = "playing";
  finalVictory = false;
  atSea = (n >= 31 && n <= 35);

  if (n !== 0 && helmetCooldownRounds > 0) {
    helmetCooldownRounds = Math.max(helmetCooldownRounds - 1, 0);
  }
  helmetActive = false;

  if (atSea) {
    boat = {
      x: W / 2 - 160,
      y: seaY,
      w: 320,
      h: 140
    };
    player.x = boat.x + boat.w / 2 - player.w / 2;
    player.y = boat.y - boat.h + 40;
  } else {
    boat = null;
    player.x = 40;
    player.y = groundY - player.h;
  }

  player.vx = 0;
  player.vy = 0;
  player.onGround = true;
  player.isRolling = false;
  player.rollTimer = 0;
  player.rollCooldown = 0;
  player.rollDir = 0;
  player.h = 32;
  player.hp = player.maxHp;
  updateHPHUD();

  boss = null;
  greekShips = [];
  groundObstacles = [];
  fallingObstacles = [];
  lowObstacles = [];
  groundSpawnTimer = 0;
  fallingSpawnTimer = 0;
  projectiles = [];
  weaponDrops = [];
  waves = [];
  lightningStrikes = [];
  infernos = [];
  allies = [];

  damageCooldown = 0;
  deathLock = false;
  levelComplete = false;
  specialCooldown = 0;

  timeSlowActive = false;
  timeFreezeActive = false;
  timeSlowTimer = 0;
  timeFreezeTimer = 0;
  timeCharmUsedThisLevel = false;

  document.getElementById("level").textContent = n;

  if (n === 0) {
    toast("Tutorial: Move (Arrows/WASD), Jump (Up/W), Attack (Space), Specials (J/K/L), Roll (Down), Switch (Q/W/E/R/T/Z/V/Y/X), Inventory (I), Time Charm (H).");
    return;
  }

  if (bossDefs[n]) {
    spawnBoss(bossDefs[n]);
    spawnAlliesForLevel();
  }

  if (n === 35) {
    spawnGreekShipsForFinal();
    toast("Final Battle: Defeat the Greek ships!");
  } else if (n >= 31 && n <= 34) {
    toast("Escape by sea! Avoid debris and arrows.");
  }

  applyEquipmentEffects();
  updateEquipHUD();
}

/* =========================================================
   Boss collision damage (HP version)
   ========================================================= */
function applyBossCollisionDamage() {
  if (!boss) return;

  if (collides(player, boss)) {
    if (damageCooldown <= 0 && !deathLock) {
      if (helmetActive) {
        toast(boss.name + " cannot see you!");
        damageCooldown = 0.4;
        return;
      }

      const dmg = scaleEnemyDamage(15);

      if (shieldActive) {
        shieldActive = false;
        equipment.shield = null;
        applyEquipmentEffects();
        updateEquipHUD();
        damageCooldown = 0.4;
        toast("Shield blocked the hit!");
      } else {
        player.hp -= dmg;
        updateHPHUD();
        damageCooldown = 0.8;
        toast(boss.name + " hit you for " + dmg + " HP!");

        if (player.hp <= 0 && !deathLock) {
          deathLock = true;
          toast("You have fallen...");
          setTimeout(() => startLevel(currentLevel), 1200);
        }
      }
    }
  }
}

/* =========================================================
   Greek ship collision damage (HP version)
   ========================================================= */
function applyShipCollisionDamage(ship) {
  const shipBox = {
    x: ship.x,
    y: ship.y - ship.h,
    w: ship.w,
    h: ship.h
  };

  if (collides(player, shipBox)) {
    if (damageCooldown <= 0 && !deathLock) {
      if (helmetActive) {
        toast("The ship cannot find you!");
        damageCooldown = 0.4;
        return;
      }

      const dmg = scaleEnemyDamage(15);

      if (shieldActive) {
        shieldActive = false;
        equipment.shield = null;
        applyEquipmentEffects();
        updateEquipHUD();
        damageCooldown = 0.4;
        toast("Shield blocked the ram!");
      } else {
        player.hp -= dmg;
        updateHPHUD();
        damageCooldown = 0.8;
        toast("Struck by a Greek ship for " + dmg + " HP!");

        if (player.hp <= 0 && !deathLock) {
          deathLock = true;
          toast("You have fallen...");
          setTimeout(() => startLevel(currentLevel), 1200);
        }
      }
    }
  }
}

/* =========================================================
   Obstacle damage (HP version)
   ========================================================= */
function applyObstacleDamage(dmg, message) {
  if (damageCooldown <= 0 && !deathLock) {
    if (shieldActive) {
      shieldActive = false;
      equipment.shield = null;
      applyEquipmentEffects();
      updateEquipHUD();
      damageCooldown = 0.4;
      toast("Shield blocked the hit!");
    } else {
      player.hp -= dmg;
      updateHPHUD();
      damageCooldown = 0.8;
      toast(message);

      if (player.hp <= 0 && !deathLock) {
        deathLock = true;
        toast("You have fallen...");
        setTimeout(() => startLevel(lastBossBeaten || 0), 1200);
      }
    }
  }
}

/* =========================================================
   Main obstacle update logic
   ========================================================= */
function updateObstacles(dt) {
  const dmgGround = scaleEnemyDamage(5);
  const dmgFalling = scaleEnemyDamage(7);
  const dmgLow = scaleEnemyDamage(5);

  for (let i = groundObstacles.length - 1; i >= 0; i--) {
    const o = groundObstacles[i];
    o.x -= o.speed * dt;

    if (collides(player, o) && !helmetActive) {
      applyObstacleDamage(dmgGround, atSea ? "Struck floating debris!" : "Hit an obstacle!");
    }

    if (o.x + o.w < 0) {
      maybeSpawnWeaponDropAt(o.x, o.y);
      groundObstacles.splice(i, 1);
    }
  }

  for (let i = fallingObstacles.length - 1; i >= 0; i--) {
    const o = fallingObstacles[i];
    o.y += o.vy * dt;

    if (collides(player, o) && !helmetActive) {
      applyObstacleDamage(dmgFalling, atSea ? "Hit by Greek arrows!" : "Hit by falling debris!");
    }

    if (o.y > H) {
      maybeSpawnWeaponDropAt(o.x, o.y);
      fallingObstacles.splice(i, 1);
    }
  }

  for (let i = lowObstacles.length - 1; i >= 0; i--) {
    const o = lowObstacles[i];
    o.x -= o.speed * dt;

    if (!player.isRolling && collides(player, o) && !helmetActive) {
      applyObstacleDamage(dmgLow, "Hit a low obstacle!");
    }

    if (o.x + o.w < 0) {
      maybeSpawnWeaponDropAt(o.x, o.y);
      lowObstacles.splice(i, 1);
    }
  }
}

/* =========================================================
   Level progression
   ========================================================= */
function checkLevelProgress() {
  if (isBossLevel(currentLevel) && !levelComplete) {
    if (!boss && weaponDrops.length === 0) {
      levelComplete = true;
      toast("Boss defeated!");
      setTimeout(() => startLevel(currentLevel + 1), 1200);
    }
  }

  if (!isBossLevel(currentLevel) && !atSea && !levelComplete && currentLevel < 31) {
    if (player.x + player.w >= W - 5) {
      levelComplete = true;
      toast("Level Complete!");
      setTimeout(() => startLevel(currentLevel + 1), 800);
    }
  }

  if (atSea && currentLevel >= 31 && currentLevel <= 34 && !levelComplete) {
    if (player.x + player.w >= W - 5) {
      levelComplete = true;
      toast("You sail onward...");
      setTimeout(() => startLevel(currentLevel + 1), 800);
    }
  }

  if (currentLevel === 35 && !levelComplete && greekShips.length === 0) {
    levelComplete = true;
    finalVictory = true;
    lastBossBeaten = 35;
    toast("Well Done! You Escaped From Troy");
    gameState = "ended";
  }
}

/* =========================================================
   Weapon drop pickup logic
   ========================================================= */
function updateWeaponDrops() {
  for (let i = weaponDrops.length - 1; i >= 0; i--) {
    const drop = weaponDrops[i];

    if (collides(player, drop)) {
      const key = drop.weaponKey;

      if (key === "helmet") {
        if (!gearOwned.helmet) {
          gearOwned.helmet = true;
          addItemToInventory("helmet_invisibility");
          toast("You obtained the Helmet of Invisibility!");
        }
      } else if (key === "shield") {
        if (!weaponsOwned.shield) {
          weaponsOwned.shield = true;
          addItemToInventory("shield_item");
          toast("You obtained a Shield!");
        }
      } else if (
        key === "chaos_charm" ||
        key === "blood_charm" ||
        key === "time_skip_charm" ||
        key === "time_slow_charm" ||
        key === "time_rewind_charm" ||
        key === "time_freeze_charm" ||
        key === "fate_charm"
      ) {
        const already = inventory.some(it => it && it.id === key);
        if (!already) {
          addItemToInventory(key);
          toast("You obtained the " + itemData[key].name + "!");
        }
      } else {
        if (!weaponsOwned[key]) {
          weaponsOwned[key] = true;
          addItemToInventory(key);
          toast("You obtained the " + itemData[key].name + "!");
        }
      }

      weaponDrops.splice(i, 1);
    }
  }
}

/* =========================================================
   Drawing
   ========================================================= */
function drawBackground() {
  if (atSea) {
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, "#031427");
    g.addColorStop(0.5, "#0a2640");
    g.addColorStop(1, "#05314a");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = "#0c4568";
    ctx.fillRect(0, seaY, W, H - seaY);
  } else {
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, "#071028");
    g.addColorStop(1, "#0b2a3a");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = "#3b2b1a";
    ctx.fillRect(0, groundY, W, 64);
  }
}

function drawBoat() {
  if (!atSea || !boat) return;

  if (boatImg.complete && boatImg.naturalWidth > 0) {
    ctx.drawImage(boatImg, boat.x, boat.y - boat.h, boat.w, boat.h);
  } else {
    ctx.fillStyle = "#704214";
    ctx.fillRect(boat.x, boat.y - boat.h, boat.w, boat.h);
  }
}

function drawPlayer() {
  if (aeneasImg.complete && aeneasImg.naturalWidth > 0) {
    ctx.drawImage(aeneasImg, player.x - 8, player.y - 8, player.w * 2.5, player.h * 2.5);
  } else {
    ctx.fillStyle = "#ccc";
    ctx.fillRect(player.x, player.y, player.w, player.h);
  }

  if (shieldActive) {
    ctx.strokeStyle = "#00ffff";
    ctx.lineWidth = 2;
    ctx.strokeRect(player.x - 4, player.y - 4, player.w + 8, player.h + 8);
  }

  if (helmetActive) {
    ctx.strokeStyle = "#ffff88";
    ctx.lineWidth = 2;
    ctx.strokeRect(player.x - 6, player.y - 6, player.w + 12, player.h + 12);
  }
}

function drawBoss() {
  if (!boss) return;
  const img = bossImages[boss.name];

  if (img && img.complete && img.naturalWidth > 0) {
    ctx.drawImage(img, boss.x, boss.y, boss.w, boss.h);
  } else {
    ctx.fillStyle = "#444";
    ctx.fillRect(boss.x, boss.y, boss.w, boss.h);
  }
}

function drawGreekShips() {
  if (currentLevel !== 35 || !greekShips.length) return;

  greekShips.forEach(ship => {
    const img = (greekShipImg.complete && greekShipImg.naturalWidth > 0)
      ? greekShipImg
      : boatImg;

    if (img && img.complete && img.naturalWidth > 0) {
      ctx.drawImage(img, ship.x, ship.y - ship.h, ship.w, ship.h);
    } else {
      ctx.fillStyle = "#883333";
      ctx.fillRect(ship.x, ship.y - ship.h, ship.w, ship.h);
    }
  });
}

function drawObstacles() {
  ctx.fillStyle = (currentLevel >= 31 && currentLevel <= 35) ? "#bba46a" : "#8b5a2b";
  groundObstacles.forEach(o => ctx.fillRect(o.x, o.y, o.w, o.h));

  ctx.fillStyle = (currentLevel >= 31 && currentLevel <= 35) ? "#e0e0ff" : "#4444aa";
  fallingObstacles.forEach(o => ctx.fillRect(o.x, o.y, o.w, o.h));

  ctx.fillStyle = "#aa8844";
  lowObstacles.forEach(o => ctx.fillRect(o.x, o.y, o.w, o.h));
}

function drawProjectiles() {
  projectiles.forEach(p => {
    if (p.type === "flame") ctx.fillStyle = "#ff8844";
    else if (p.type === "lightning") ctx.fillStyle = "#ffff55";
    else if (p.type === "arrow") ctx.fillStyle = "#ffdd55";
    else if (p.type === "artemisArrow") ctx.fillStyle = "#ddddff";
    else ctx.fillStyle = "#ffdd55";

    ctx.fillRect(p.x, p.y, p.w, p.h);
  });
}

function drawWeaponDrops() {
  weaponDrops.forEach(drop => {
    switch (drop.weaponKey) {
      case "bow":        ctx.fillStyle = "#ffaa00"; break;
      case "artemisBow": ctx.fillStyle = "#dddddd"; break;
      case "shield":     ctx.fillStyle = "#88ffff"; break;
      case "axe":        ctx.fillStyle = "#ff5555"; break;
      case "spear":      ctx.fillStyle = "#ffffff"; break;
      case "trident":    ctx.fillStyle = "#55ff55"; break;
      case "lightning":  ctx.fillStyle = "#ffff55"; break;
      case "torch":      ctx.fillStyle = "#ff8844"; break;
      case "helmet":     ctx.fillStyle = "#bbbbbb"; break;
      case "chaos_charm": ctx.fillStyle = "#ff00ff"; break;
      case "blood_charm": ctx.fillStyle = "#aa0000"; break;
      case "time_skip_charm": ctx.fillStyle = "#66ccff"; break;
      case "time_slow_charm": ctx.fillStyle = "#6699ff"; break;
      case "time_rewind_charm": ctx.fillStyle = "#cc66ff"; break;
      case "time_freeze_charm": ctx.fillStyle = "#99ffff"; break;
      case "fate_charm": ctx.fillStyle = "#ffcc33"; break;
      default:           ctx.fillStyle = "#cccccc"; break;
    }
    ctx.fillRect(drop.x, drop.y, drop.w, drop.h);
  });
}

function drawWaves() {
  waves.forEach(wave => {
    if (!wave.alive) return;

    if (waveImgLoaded && waveImg.complete && waveImg.naturalWidth > 0) {
      ctx.drawImage(waveImg, wave.x, wave.y, wave.w, wave.h);
    } else {
      const g = ctx.createLinearGradient(wave.x, wave.y, wave.x, wave.y + wave.h);
      g.addColorStop(0, "#88d9ff");
      g.addColorStop(0.5, "#3ba3ff");
      g.addColorStop(1, "#005b96");
      ctx.fillStyle = g;
      ctx.fillRect(wave.x, wave.y, wave.w, wave.h);
    }
  });
}

function drawLightningStrikes() {
  lightningStrikes.forEach(s => {
    ctx.fillStyle = "rgba(255,255,150,0.8)";
    ctx.fillRect(s.x, 0, s.w, H);
  });
}

function drawInfernos() {
  infernos.forEach(inf => {
    if (!inf.alive) return;

    const g = ctx.createRadialGradient(
      inf.x, inf.y, inf.radius * 0.1,
      inf.x, inf.y, inf.radius
    );
    g.addColorStop(0, "rgba(255,255,200,0.8)");
    g.addColorStop(0.4, "rgba(255,180,80,0.7)");
    g.addColorStop(1, "rgba(140,30,0,0.0)");
    ctx.fillStyle = g;

    ctx.beginPath();
    ctx.arc(inf.x, inf.y, inf.radius, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawLevelJumpWarning() {
  if (!levelJumpUsed) return;
  ctx.fillStyle = "yellow";
  ctx.font = "24px sans-serif";
  ctx.fillText("LEVEL JUMP ENABLED", 20, 40);
}

function drawFinalVictory() {
  if (!finalVictory) return;

  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = "#fff";
  ctx.font = "40px sans-serif";
  ctx.textAlign = "center";
  ctx.fillText("Well Done!", W / 2, H / 2 - 20);
  ctx.fillText("You Escaped From Troy", W / 2, H / 2 + 30);
  ctx.textAlign = "left";
}

/* =========================================================
   Main draw
   ========================================================= */
function draw() {
  ctx.clearRect(0, 0, W, H);

  drawBackground();
  drawBoat();
  drawPlayer();
  drawBoss();
  drawGreekShips();
  drawObstacles();
  drawProjectiles();
  drawWeaponDrops();
  drawWaves();
  drawLightningStrikes();
  drawInfernos();
  drawAllies();
  drawLevelJumpWarning();
  drawFinalVictory();

  if (gameState === "inventory") {
    drawInventoryUI();
  }

  document.getElementById("time").textContent = t.toFixed(1);
}

/* =========================================================
   Main update loop
   ========================================================= */
function update(now) {
  const rawDt = (now - last) / 1000;
  last = now;

  if (damageCooldown > 0) damageCooldown -= rawDt;
  if (specialCooldown > 0) specialCooldown -= rawDt;

  if (timeSlowActive) {
    timeSlowTimer -= rawDt;
    if (timeSlowTimer <= 0) {
      timeSlowActive = false;
      toast("Time returns to normal.");
    }
  }

  if (timeFreezeActive) {
    timeFreezeTimer -= rawDt;
    if (timeFreezeTimer <= 0) {
      timeFreezeActive = false;
      toast("Time flows again.");
    }
  }

  const worldDt = timeFreezeActive
    ? 0
    : (timeSlowActive ? rawDt * 0.5 : rawDt);

  if (gameState === "playing") {
    t += rawDt;

    updatePlayer(rawDt);

    if (atSea && boat && currentLevel >= 31 && currentLevel <= 34) {
      boat.x += 60 * worldDt;
    }

    if (atSea && boat && currentLevel >= 31 && currentLevel <= 35) {
      if (player.x < boat.x) player.x = boat.x;
      if (player.x + player.w > boat.x + boat.w) player.x = boat.x + boat.w - player.w;

      const deckY = boat.y - boat.h + 40;
      if (player.y > deckY) {
        player.y = deckY;
        player.vy = 0;
        player.onGround = true;
      }
    }

    updateProjectiles(worldDt);
    updateWaves(worldDt);
    updateLightning(worldDt);
    updateInfernos(worldDt);
    updateObstacles(worldDt);
    updateAllies(worldDt);
    updateWeaponDrops();

    applyBossCollisionDamage();

    if (currentLevel === 35) {
      for (let i = greekShips.length - 1; i >= 0; i--) {
        const ship = greekShips[i];
        ship.x += ship.vx * worldDt;

        applyShipCollisionDamage(ship);

        if (ship.x + ship.w < 0) {
          greekShips.splice(i, 1);
        }
      }
    }

    if (!isBossLevel(currentLevel) && currentLevel !== 35) {
      groundSpawnTimer += worldDt;
      if (groundSpawnTimer > 2) {
        if (Math.random() < 0.25) spawnLowObstacle();
        else spawnGroundObstacle();
        groundSpawnTimer = 0;
      }

      fallingSpawnTimer += worldDt;
      if (fallingSpawnTimer > 1.5) {
        spawnFallingObstacle();
        fallingSpawnTimer = 0;
      }
    }

    checkLevelProgress();
  }

  draw();
  requestAnimationFrame(update);
}

/* =========================================================
   Equip HUD
   ========================================================= */
function updateEquipHUD() {
  const hud = document.getElementById("equipHUD");

  const w = equipment.weapon ? itemData[equipment.weapon].name : "None";
  const h = equipment.helmet ? itemData[equipment.helmet].name : "None";
  const s = equipment.shield ? itemData[equipment.shield].name : "None";
  const c = equipment.charm ? itemData[equipment.charm].name : "None";

  hud.textContent = `Weapon: ${w} | Helmet: ${h} | Shield: ${s} | Charm: ${c}`;
}

/* =========================================================
   Inventory open/close
   ========================================================= */
function openInventory() {
  if (gameState === "playing") {
    gameState = "inventory";
    toast("Inventory opened");
  }
}

function closeInventory() {
  if (gameState === "inventory") {
    gameState = "playing";
    draggingItem = null;
    toast("Inventory closed");
  }
}

/* =========================================================
   Cheat unlock
   ========================================================= */
function unlockAll() {
  weaponsOwned = {
    sword: true,
    axe: true,
    bow: true,
    artemisBow: true,
    spear: true,
    trident: true,
    shield: true,
    lightning: true,
    torch: true
  };

  gearOwned.helmet = true;
  shieldActive = true;

  const allIds = [
    "sword","axe","bow","artemisBow","spear","trident","lightning","torch",
    "shield_item","helmet_invisibility","chaos_charm","blood_charm",
    "time_skip_charm","time_slow_charm","time_rewind_charm","time_freeze_charm","fate_charm"
  ];

  for (let i = 0; i < allIds.length; i++) {
    addItemToInventory(allIds[i]);
  }

  toast("All weapons and gear activated");
}

/* =========================================================
   Toast helper
   ========================================================= */
function toast(msg) {
  document.getElementById("msg").textContent = msg;
}

/* =========================================================
   Init
   ========================================================= */
startLevel(0);
updateEquipHUD();
updateHPHUD();
requestAnimationFrame(update);
</script>
</body>
</html>
