<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Escape From Troy</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: sans-serif;
      overflow: hidden;
    }
    #hud {
      position: absolute;
      top: 8px;
      left: 8px;
      font-size: 14px;
      z-index: 10;
    }
    #msg {
      position: absolute;
      bottom: 8px;
      left: 8px;
      font-size: 16px;
      z-index: 10;
    }
    #equipHUD {
      position: absolute;
      top: 8px;
      right: 8px;
      font-size: 14px;
      z-index: 10;
    }
    #shopOverlay {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: none;
      z-index: 20;
      color: #fff;
    }
    #shopOverlayInner {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: #222;
      border: 2px solid #aaa;
      padding: 16px;
      width: 520px;
      max-width: 90%;
    }
    #shopTitle {
      font-size: 20px;
      margin-bottom: 8px;
    }
    #shopGrid {
      display: grid;
      grid-template-columns: repeat(5, 80px);
      grid-auto-rows: 80px;
      gap: 8px;
      margin-top: 8px;
    }
    .shopItem {
      border: 1px solid #555;
      position: relative;
      cursor: pointer;
      background: #111;
    }
    .shopItem span {
      position: absolute;
      bottom: 2px;
      left: 2px;
      right: 2px;
      font-size: 11px;
      text-align: center;
    }
    .shopCost {
      position: absolute;
      top: 2px;
      right: 2px;
      font-size: 11px;
      background: rgba(0,0,0,0.6);
      padding: 1px 3px;
      border-radius: 3px;
    }
    #shopCloseBtn {
      margin-top: 10px;
      padding: 4px 10px;
      background: #444;
      border: 1px solid #888;
      color: #fff;
      cursor: pointer;
    }
    #questInfo {
      margin-top: 8px;
      font-size: 13px;
    }
  </style>
</head>
<body>
<div id="hud">
  Level: <span id="level">0</span> |
  Time: <span id="time">0.0</span> |
  HP: <span id="hp">100</span> |
  Drachma: <span id="drachma">0</span>
</div>
<div id="equipHUD"></div>
<div id="msg"></div>

<div id="shopOverlay">
  <div id="shopOverlayInner">
    <div id="shopTitle">Shop</div>
    <div id="questInfo" style="display:none;"></div>
    <div id="shopGrid"></div>
    <button id="shopCloseBtn">Close</button>
  </div>
</div>

<canvas id="game" width="960" height="540"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
let W = canvas.width;
let H = canvas.height;

let t = 0;
let last = performance.now();

let gameState = "title"; // "title", "playing", "inventory", "troy", "ended"

let atSea = false;
const groundY = 400;
const seaY = 360;

const BASE_SPEED = 200;
const BASE_JUMP = 420;

let player = {
  x: 40,
  y: groundY - 32,
  w: 20,
  h: 32,
  vx: 0,
  vy: 0,
  speed: BASE_SPEED,
  jump: BASE_JUMP,
  onGround: true,
  isRolling: false,
  rollTimer: 0,
  rollCooldown: 0,
  rollDir: 0,
  maxHp: 100,
  hp: 100
};

let keys = {};
let mouseX = 0;
let mouseY = 0;

let damageCooldown = 0;
let deathLock = false;
let levelComplete = false;
let finalVictory = false;

let specialCooldown = 0;

let projectiles = [];
let weaponDrops = [];
let waves = [];
let lightningStrikes = [];
let infernos = [];
let enemies = [];
let allies = [];
let greekShips = [];
let boat = null;

let trojanSpawnTimer = 0;

let shieldActive = false;
let helmetActive = false;
let helmetCooldownRounds = 0;

let weaponsOwned = {
  sword: false,
  axe: false,
  bow: false,
  artemisBow: false,
  spear: false,
  trident: false,
  shield: false,
  lightning: false,
  torch: false
};

let gearOwned = {
  helmet: false
};

let equipment = {
  weapon: null,
  helmet: null,
  shield: null,
  charm: null,
  mount: null,
  chariot: null
};

let currentWeapon = "sword";

let potionDamageMultiplier = 1;
let potionSpeedMultiplier = 1;
let potionJumpMultiplier = 1;
let potionAegisActive = false;

let timeSlowActive = false;
let timeSlowTimer = 0;
let timeFreezeActive = false;
let timeFreezeTimer = 0;
let lastTimeCharmUseLevel = -999;

let inventory = [];
const INVENTORY_ROWS = 6;
const INVENTORY_COLS = 8;

let invUI = {
  x: 80,
  y: 40,
  w: 800,
  h: 440,
  padding: 20,
  cellSize: 56
};

let inventoryScroll = 0;
let maxInventoryScroll = 0;

let draggingItem = null;
let dragOffsetX = 0;
let dragOffsetY = 0;

let itemImages = {};
// === ITEM ICONS ===
itemImages["sword"] = new Image();
itemImages["sword"].src = "icons/sword.png";

itemImages["axe"] = new Image();
itemImages["axe"].src = "icons/axe.png";

itemImages["bow"] = new Image();
itemImages["bow"].src = "icons/bow.png";

itemImages["artemisBow"] = new Image();
itemImages["artemisBow"].src = "icons/artemis_bow.png";

itemImages["spear"] = new Image();
itemImages["spear"].src = "icons/spear.png";

itemImages["trident"] = new Image();
itemImages["trident"].src = "icons/trident.png";

itemImages["lightning"] = new Image();
itemImages["lightning"].src = "icons/lightning.png";

itemImages["torch"] = new Image();
itemImages["torch"].src = "icons/torch.png";

itemImages["shield_item"] = new Image();
itemImages["shield_item"].src = "icons/shield.png";

itemImages["helmet_invisibility"] = new Image();
itemImages["helmet_invisibility"].src = "icons/helmet.png";

itemImages["chaos_charm"] = new Image();
itemImages["chaos_charm"].src = "icons/chaos_charm.png";

itemImages["blood_charm"] = new Image();
itemImages["blood_charm"].src = "icons/blood_charm.png";

itemImages["time_skip_charm"] = new Image();
itemImages["time_skip_charm"].src = "icons/time_skip.png";

itemImages["time_slow_charm"] = new Image();
itemImages["time_slow_charm"].src = "icons/time_slow.png";

itemImages["time_rewind_charm"] = new Image();
itemImages["time_rewind_charm"].src = "icons/time_rewind.png";

itemImages["time_freeze_charm"] = new Image();
itemImages["time_freeze_charm"].src = "icons/time_freeze.png";

itemImages["mount_lion"] = new Image();
itemImages["mount_lion"].src = "icons/lion.png";

itemImages["mount_pegasus"] = new Image();
itemImages["mount_pegasus"].src = "icons/pegasus.png";

itemImages["mount_bull"] = new Image();
itemImages["mount_bull"].src = "icons/bull.png";

itemImages["mount_horse"] = new Image();
itemImages["mount_horse"].src = "icons/horse.png";

itemImages["chariot_normal"] = new Image();
itemImages["chariot_normal"].src = "icons/chariot.png";

itemImages["chariot_helios"] = new Image();
itemImages["chariot_helios"].src = "icons/chariot_helios.png";

itemImages["potion_strength"] = new Image();
itemImages["potion_strength"].src = "icons/potion_strength.png";

itemImages["potion_swiftness"] = new Image();
itemImages["potion_swiftness"].src = "icons/potion_swiftness.png";

itemImages["potion_fortitude"] = new Image();
itemImages["potion_fortitude"].src = "icons/potion_fortitude.png";

itemImages["potion_aegis"] = new Image();
itemImages["potion_aegis"].src = "icons/potion_aegis.png";

let allyImages = {};

// === ALLY IMAGES ===
allyImages["hector"] = new Image();
allyImages["hector"].src = "allies/hector.png";

allyImages["paris"] = new Image();
allyImages["paris"].src = "allies/paris.png";

allyImages["priam"] = new Image();
allyImages["priam"].src = "allies/priam.png";

allyImages["helen"] = new Image();
allyImages["helen"].src = "allies/helen.png";

let enemyImages = {};

// === ENEMY SOLDIER IMAGES ===
enemyImages["foot"] = new Image();
enemyImages["foot"].src = "enemies/foot.png";

enemyImages["spear"] = new Image();
enemyImages["spear"].src = "enemies/spear.png";

enemyImages["shield"] = new Image();
enemyImages["shield"].src = "enemies/shield.png";

enemyImages["archer"] = new Image();
enemyImages["archer"].src = "enemies/archer.png";

let bossImages = {};

// === BOSS IMAGES ===
bossImages["Menelaus"] = new Image();
bossImages["Menelaus"].src = "bosses/menelaus.png";

bossImages["Agamemnon"] = new Image();
bossImages["Agamemnon"].src = "bosses/agamemnon.png";

bossImages["Diomedes"] = new Image();
bossImages["Diomedes"].src = "bosses/diomedes.png";

bossImages["Ajax"] = new Image();
bossImages["Ajax"].src = "bosses/ajax.png";

bossImages["Achilles"] = new Image();
bossImages["Achilles"].src = "bosses/achilles.png";

bossImages["Trojan Horse"] = new Image();
bossImages["Trojan Horse"].src = "bosses/trojan_horse.png";

// === TROY BUILDING IMAGES ===
let troyBuildingImages = {};

troyBuildingImages["shop"] = new Image();
troyBuildingImages["shop"].src = "troy/shop.png";

troyBuildingImages["blacksmith"] = new Image();
troyBuildingImages["blacksmith"].src = "troy/blacksmith.png";

troyBuildingImages["stables"] = new Image();
troyBuildingImages["stables"].src = "troy/stables.png";

troyBuildingImages["temple"] = new Image();
troyBuildingImages["temple"].src = "troy/temple.png";

troyBuildingImages["searchers_lounge"] = new Image();
troyBuildingImages["searchers_lounge"].src = "troy/searchers_lounge.png";

let titleScreenImg = new Image();
let boatImg = new Image();
let aeneasImg = new Image();
let greekShipImg = new Image();
let waveImg = new Image();
let waveImgLoaded = false;

titleScreenImg.src = "title.png";
boatImg.src = "boat.png";
aeneasImg.src = "aeneas.png";
greekShipImg.src = "greek_ship.png";
waveImg.src = "wave.png";
waveImg.onload = () => waveImgLoaded = true;

let itemData = {
  sword: { name: "Sword", type: "weapon", slot: "weapon", baseDamage: 5 },
  axe: { name: "Axe", type: "weapon", slot: "weapon", baseDamage: 6 },
  bow: { name: "Bow", type: "weapon", slot: "weapon", baseDamage: 4 },
  artemisBow: { name: "Artemis Bow", type: "weapon", slot: "weapon", baseDamage: 5 },
  spear: { name: "Spear", type: "weapon", slot: "weapon", baseDamage: 6 },
  trident: { name: "Trident", type: "weapon", slot: "weapon", baseDamage: 7 },
  lightning: { name: "Lightning Bolt", type: "weapon", slot: "weapon", baseDamage: 7 },
  torch: { name: "Torch", type: "weapon", slot: "weapon", baseDamage: 5 },
  shield_item: { name: "Shield", type: "shield", slot: "shield" },
  helmet_invisibility: { name: "Helmet of Invisibility", type: "helmet", slot: "helmet" },
  chaos_charm: { name: "Chaos Charm", type: "charm", slot: "charm" },
  blood_charm: { name: "Blood Charm", type: "charm", slot: "charm" },
  time_skip_charm: { name: "Time Skip Charm", type: "charm", slot: "charm" },
  time_slow_charm: { name: "Time Slow Charm", type: "charm", slot: "charm" },
  time_rewind_charm: { name: "Time Rewind Charm", type: "charm", slot: "charm" },
  time_freeze_charm: { name: "Time Freeze Charm", type: "charm", slot: "charm" },
  mount_lion: { name: "Lion Mount", type: "mount", slot: "mount" },
  mount_pegasus: { name: "Pegasus Mount", type: "mount", slot: "mount" },
  mount_bull: { name: "Bull Mount", type: "mount", slot: "mount" },
  mount_horse: { name: "Horse Mount", type: "mount", slot: "mount" },
  chariot_normal: { name: "Chariot", type: "chariot", slot: "chariot" },
  chariot_helios: { name: "Helios Chariot", type: "chariot", slot: "chariot" },
  potion_strength: { name: "Potion of Strength", type: "potion" },
  potion_swiftness: { name: "Potion of Swiftness", type: "potion" },
  potion_fortitude: { name: "Potion of Fortitude", type: "potion" },
  potion_aegis: { name: "Potion of Aegis", type: "potion" }
};

let weapons = {
  sword: { type: "melee", damage: 5, range: 40 },
  axe: { type: "melee", damage: 6, range: 45 },
  bow: { type: "projectile", damage: 4, range: 0, projectileSpeed: 360, homing: false },
  artemisBow: { type: "projectile", damage: 5, range: 0, projectileSpeed: 380, homing: true },
  spear: { type: "melee", damage: 6, meleeRange: 50, throwSpeed: 380 },
  trident: { type: "melee", damage: 7, meleeRange: 55, throwSpeed: 360 },
  lightning: { type: "melee", damage: 7, meleeRange: 50, throwSpeed: 400 },
  torch: { type: "melee", damage: 5, meleeRange: 40, throwSpeed: 320 }
};

let currentLevel = 0;
let levelJumpUsed = false;
let lastBossBeaten = 0;

let groundObstacles = [];
let fallingObstacles = [];
let lowObstacles = [];
let groundSpawnTimer = 0;
let fallingSpawnTimer = 0;

let bossDefs = {
  5:  { name: "Menelaus",     hp: 6  },
  10: { name: "Agamemnon",    hp: 8  },
  15: { name: "Diomedes",     hp: 10 },
  20: { name: "Ajax",         hp: 12 },
  25: { name: "Achilles",     hp: 15 },
  30: { name: "Trojan Horse", hp: 20 }
};

let boss = null;

let timeSlowCharmOwned = false;

let drachma = 0;
let questProgress = {
  totalQuests: 5,
  completed: 0
};
let allQuestsComplete = false;

const troyBuildings = [
  { id: "shop", x: 140, y: groundY - 80, w: 80, h: 80, label: "Shop" },
  { id: "blacksmith", x: 260, y: groundY - 80, w: 80, h: 80, label: "Blacksmith" },
  { id: "stables", x: 380, y: groundY - 80, w: 80, h: 80, label: "Stables" },
  { id: "temple", x: 500, y: groundY - 80, w: 80, h: 80, label: "Temple" },
  { id: "searchers_lounge", x: 620, y: groundY - 80, w: 80, h: 80, label: "Searcher’s Lounge" }
];

let shopMode = null; // "shop", "blacksmith", "stables", "temple", "searchers_lounge"

function updateHPHUD() {
  document.getElementById("hp").textContent = player.hp;
}

function updateDrachmaHUD() {
  document.getElementById("drachma").textContent = drachma;
}

function scalePlayerDamage(base) {
  return Math.round(base * potionDamageMultiplier);
}

function scaleEnemyDamage(base) {
  return base;
}

function collides(a, b) {
  return (
    a.x < b.x + b.w &&
    a.x + a.w > b.x &&
    a.y < b.y + b.h &&
    a.y + a.h > b.y
  );
}

/* =========================================================
   Player update
   ========================================================= */
function updatePlayer(dt) {
  player.vx = 0;

  if (keys["arrowleft"] || keys["a"]) {
    player.vx = -player.speed;
  }
  if (keys["arrowright"] || keys["d"]) {
    player.vx = player.speed;
  }

  if ((keys["arrowup"] || keys["w"]) && player.onGround) {
    player.vy = -player.jump;
    player.onGround = false;
  }

  player.vy += 900 * dt;
  player.x += player.vx * dt;
  player.y += player.vy * dt;

  if (!atSea) {
    if (player.y + player.h >= groundY) {
      player.y = groundY - player.h;
      player.vy = 0;
      player.onGround = true;
    }
  }

  if (player.isRolling) {
    player.rollTimer -= dt;
    if (player.rollTimer <= 0) {
      player.isRolling = false;
      player.h = 32;
    } else {
      player.h = 20;
      player.y = groundY - player.h;
      player.x += player.rollDir * 260 * dt;
    }
  }

  if (player.rollCooldown > 0) {
    player.rollCooldown -= dt;
  }
}

/* =========================================================
   Basic attack (Space)
   ========================================================= */
function playerAttack() {
  const weapon = weapons[currentWeapon];
  if (!weapon) return;

  if (weapon.type === "melee") {
    const dmg = scalePlayerDamage(weapon.damage);
    const range = weapon.range || weapon.meleeRange || 40;

    const hitbox = {
      x: player.x + player.w,
      y: player.y,
      w: range,
      h: player.h
    };

    if (boss && collides(hitbox, boss)) {
      boss.hp -= dmg;
      toast("Hit " + boss.name + "!");
      if (boss.hp <= 0) {
        toast(boss.name + " defeated!");
        lastBossBeaten = currentLevel;
        drachma += 20;
        updateDrachmaHUD();
        maybeSpawnWeaponDropAt(boss.x + boss.w / 2, boss.y);
        boss = null;
      }
    }

    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      if (!collides(hitbox, e)) continue;

      if (e.type === "shield") {
        const playerFront = player.x + player.w;
        if (playerFront <= e.x + e.w && playerFront >= e.x) {
          toast("Your strike glances off the shield!");
          continue;
        }
      }

      e.hp -= dmg;
      if (e.hp <= 0) {
        drachma += 3;
        updateDrachmaHUD();
        maybeSpawnWeaponDropAt(e.x + e.w / 2, e.y);
        enemies.splice(i, 1);
      }
    }
  }

  if (weapon.type === "projectile") {
    const px = player.x + player.w;
    const py = player.y + player.h / 2;
    const dmg = scalePlayerDamage(weapon.damage);

    projectiles.push({
      x: px,
      y: py,
      w: 18,
      h: 6,
      vx: weapon.projectileSpeed,
      vy: 0,
      damage: dmg,
      type: weapon.homing ? "artemisArrow" : "arrow",
      fromEnemy: false
    });

    toast(weapon.homing ? "Homing arrow fired!" : "Arrow loosed!");
  }
}

/* =========================================================
   J: Special Melee (20 HP base)
   ========================================================= */
function specialMelee() {
  if (specialCooldown > 0) {
    toast("Special cooling down...");
    return;
  }

  specialCooldown = 0.6;

  const base = 20;
  const dmg = scalePlayerDamage(base);

  let range = 40;

  if (currentWeapon === "spear" && weaponsOwned.spear) {
    range = weapons.spear.meleeRange + 20;
    toast("Spear jab!");
  } else if (currentWeapon === "trident" && weaponsOwned.trident) {
    range = weapons.trident.meleeRange + 20;
    toast("Trident stab!");
  } else if (currentWeapon === "axe" && weaponsOwned.axe) {
    range = weapons.axe.range + 10;
    toast("Heavy swing!");
  } else if (currentWeapon === "lightning" && weaponsOwned.lightning) {
    range = weapons.lightning.meleeRange + 20;
    toast("Charged lightning stab!");
  } else if (currentWeapon === "torch" && weaponsOwned.torch) {
    range = weapons.torch.meleeRange + 10;
    toast("Fiery smash!");
  } else {
    toast("Strong strike!");
  }

  const hitbox = {
    x: player.x + player.w,
    y: player.y,
    w: range,
    h: player.h
  };

  if (boss && collides(hitbox, boss)) {
    boss.hp -= dmg;
    toast("Critical hit on " + boss.name + "!");
    if (boss.hp <= 0) {
      toast(boss.name + " defeated!");
      lastBossBeaten = currentLevel;
      drachma += 20;
      updateDrachmaHUD();
      maybeSpawnWeaponDropAt(boss.x + boss.w / 2, boss.y);
      boss = null;
    }
  }

  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    if (!collides(hitbox, e)) continue;

    if (e.type === "shield") {
      const playerFront = player.x + player.w;
      if (playerFront <= e.x + e.w && playerFront >= e.x) {
        toast("Your mighty blow is blocked!");
        continue;
      }
    }

    e.hp -= dmg;
    if (e.hp <= 0) {
      drachma += 3;
      updateDrachmaHUD();
      maybeSpawnWeaponDropAt(e.x + e.w / 2, e.y);
      enemies.splice(i, 1);
    }
  }

  if (currentLevel === 35 && greekShips.length > 0) {
    for (let i = greekShips.length - 1; i >= 0; i--) {
      const ship = greekShips[i];
      const shipBox = {
        x: ship.x,
        y: ship.y - ship.h,
        w: ship.w,
        h: ship.h
      };

      if (collides(hitbox, shipBox)) {
        ship.hp -= dmg;
        toast("Massive hit on Greek ship!");
        if (ship.hp <= 0) {
          drachma += 20;
          updateDrachmaHUD();
          maybeSpawnWeaponDropAt(ship.x + ship.w / 2, ship.y - ship.h);
          greekShips.splice(i, 1);
        }
      }
    }
  }
}

/* =========================================================
   K: Special Throw (15 HP base)
   ========================================================= */
function specialThrow() {
  if (specialCooldown > 0) {
    toast("Special cooling down...");
    return;
  }

  specialCooldown = 0.8;

  const dmg = scalePlayerDamage(15);
  const px = player.x + player.w;
  const py = player.y + player.h / 2;

  if (currentWeapon === "spear" && weaponsOwned.spear) {
    spawnProjectile(px, py, weapons.spear.throwSpeed, dmg, "spear", false);
    toast("Spear thrown!");
  } else if (currentWeapon === "trident" && weaponsOwned.trident) {
    spawnProjectile(px, py, weapons.trident.throwSpeed, dmg, "trident", false);
    toast("Trident hurled!");
  } else if (currentWeapon === "lightning" && weaponsOwned.lightning) {
    spawnProjectile(px, py, weapons.lightning.throwSpeed, dmg, "lightning", false);
    toast("Lightning bolt thrown!");
  } else if (currentWeapon === "torch" && weaponsOwned.torch) {
    spawnProjectile(px, py, weapons.torch.throwSpeed, dmg, "flame", false);
    toast("Flame hurled!");
  } else if (currentWeapon === "artemisBow" && weaponsOwned.artemisBow) {
    projectiles.push({
      x: px,
      y: py,
      w: 20,
      h: 6,
      vx: weapons.artemisBow.projectileSpeed,
      vy: 0,
      damage: dmg,
      type: "artemisArrow",
      fromEnemy: false
    });
    toast("Homing arrow hurled!");
  } else if (weaponsOwned.bow) {
    spawnProjectile(px, py, weapons.bow.projectileSpeed, dmg, "arrow", false);
    toast("Arrow loosed!");
  }
}

/* =========================================================
   L: Weapon Ultimate Specials (30 HP base)
   ========================================================= */
function specialUltimate() {
  if (specialCooldown > 0) {
    toast("Special cooling down...");
    return;
  }

  specialCooldown = 1.2;

  const dmg = scalePlayerDamage(30);

  if (currentWeapon === "trident" && weaponsOwned.trident) {
    summonWave(dmg);
  } else if (currentWeapon === "lightning" && weaponsOwned.lightning) {
    summonLightningStorm(dmg);
  } else if (currentWeapon === "torch" && weaponsOwned.torch) {
    summonInferno(dmg);
  } else if (currentWeapon === "artemisBow" && weaponsOwned.artemisBow) {
    summonRainOfArrows(dmg);
  } else {
    toast("No special power for this weapon");
  }
}

/* =========================================================
   Projectile spawner
   ========================================================= */
function spawnProjectile(x, y, speed, damage, type, fromEnemy = false) {
  projectiles.push({
    x,
    y,
    w: 18,
    h: 6,
    vx: speed,
    vy: 0,
    damage,
    type,
    fromEnemy
  });
}

/* =========================================================
   Time powers & Time Charms
   ========================================================= */
function canUseTimeCharm() {
  if (!equipment.charm) {
    toast("No charm equipped.");
    return false;
  }
  if (currentLevel - lastTimeCharmUseLevel < 2) {
    toast("You can only use a time charm every 2 levels.");
    return false;
  }
  if (gameState !== "playing") return false;
  return true;
}

function useEquippedTimeCharm() {
  if (!canUseTimeCharm()) return;

  const id = equipment.charm;

  if (id === "time_skip_charm") {
    useTimeSkipCharm();
  } else if (id === "time_slow_charm") {
    useTimeSlowCharm();
  } else if (id === "time_rewind_charm") {
    useTimeRewindCharm();
  } else if (id === "time_freeze_charm") {
    useTimeFreezeCharm();
  } else {
    toast("This charm has no time power.");
    return;
  }

  lastTimeCharmUseLevel = currentLevel;
}

function useTimeSkipCharm() {
  if (currentLevel >= 35) {
    toast("Time cannot skip the final fate...");
    return;
  }
  if (isBossLevel(currentLevel) || isBossLevel(currentLevel + 1)) {
    toast("Time cannot skip a boss battle.");
    return;
  }
  toast("Time bends—skipping ahead!");
  levelComplete = true;
  setTimeout(() => startLevel(currentLevel + 1), 400);
}

function useTimeSlowCharm() {
  if (timeSlowActive) {
    toast("Time is already slowed...");
    return;
  }
  timeSlowActive = true;
  timeSlowTimer = 5;
  toast("Time slows around you...");
}

function useTimeRewindCharm() {
  const heal = player.maxHp * 0.3;
  player.hp = Math.min(player.maxHp, player.hp + heal);
  updateHPHUD();
  toast("Time rewinds your wounds...");
}

function useTimeFreezeCharm() {
  if (timeFreezeActive) {
    toast("Time is already frozen...");
    return;
  }
  timeFreezeActive = true;
  timeFreezeTimer = 3;
  toast("Time freezes in place...");
}

/* =========================================================
   Potion usage (click in inventory)
   ========================================================= */
function usePotion(id) {
  if (gameState !== "inventory") return;

  if (id === "potion_strength") {
    potionDamageMultiplier = 1.3;
    toast("You drink a Potion of Strength! Damage up for this level.");
  } else if (id === "potion_swiftness") {
    potionSpeedMultiplier = 1.25;
    potionJumpMultiplier = 1.1;
    applyEquipmentEffects();
    toast("You drink a Potion of Swiftness! Speed up for this level.");
  } else if (id === "potion_fortitude") {
    player.maxHp = Math.round(player.maxHp * 1.3);
    player.hp = player.maxHp;
    updateHPHUD();
    toast("You drink a Potion of Fortitude! Max HP up for this level.");
  } else if (id === "potion_aegis") {
    potionAegisActive = true;
    toast("You drink a Potion of Aegis! One hit will be negated this level.");
  }
}

/* =========================================================
   Controls
   ========================================================= */
addEventListener("keydown", e => {
  const k = e.key.toLowerCase();
  keys[k] = true;

  if (gameState === "title" && (e.key === "Enter" || e.key === " ")) {
    gameState = "playing";
    startLevel(0);
    return;
  }

  if (e.key === "F1") setDifficulty("easy");
  if (e.key === "F2") setDifficulty("medium");
  if (e.key === "F3") setDifficulty("hard");

  if ((k === "p" && keys["i"]) || (k === "i" && keys["p"])) {
    const potionIds = [
      "potion_strength",
      "potion_swiftness",
      "potion_fortitude",
      "potion_aegis"
    ];
    potionIds.forEach(id => addItemToInventory(id));
    toast("All potions added to your inventory.");
  }

  if (gameState === "inventory") {
    if (k === "i") closeInventory();
    if (e.key === "9") unlockAll();
    return;
  }

  if (gameState === "troy") {
    if (k === "shift") {
      toast("Returning to battle...");
      gameState = "playing";
      return;
    }
  }

  if (gameState === "playing") {
    if (k === "shift") {
      toast("You travel to Troy...");
      gameState = "troy";
      return;
    }
  }

  if (e.key === " " || e.key === "Spacebar") playerAttack();
  if (k === "j") specialMelee();
  if (k === "k") specialThrow();
  if (k === "l") specialUltimate();

  if (k === "arrowdown" && !player.isRolling && player.rollCooldown <= 0) {
    let dir = 0;
    if (keys["arrowleft"] || keys["a"]) dir = -1;
    if (keys["arrowright"] || keys["d"]) dir = 1;

    player.isRolling = true;
    player.rollTimer = 0.35;
    player.rollCooldown = 0.8;
    player.rollDir = dir;
    toast(dir === 0 ? "Crouch roll!" : dir < 0 ? "Roll left!" : "Roll right!");
  }

  if (k === "q" && weaponsOwned.sword) equipWeapon("sword");
  if (k === "w" && weaponsOwned.axe) equipWeapon("axe");
  if (k === "e" && (weaponsOwned.bow || weaponsOwned.artemisBow)) {
    equipWeapon(weaponsOwned.artemisBow ? "artemisBow" : "bow");
  }
  if (k === "r" && weaponsOwned.spear) equipWeapon("spear");
  if (k === "t" && weaponsOwned.trident) equipWeapon("trident");
  if (k === "z" && weaponsOwned.lightning) equipWeapon("lightning");
  if (k === "v" && weaponsOwned.torch) equipWeapon("torch");

  if (k === "y" && weaponsOwned.shield) {
    shieldActive = !shieldActive;
    equipment.shield = shieldActive ? "shield_item" : null;
    updateEquipHUD();
    toast(shieldActive ? "Shield equipped" : "Shield removed");
  }

  if (k === "x" && gearOwned.helmet) {
    if (helmetActive) {
      toast("Helmet already active this round");
    } else if (helmetCooldownRounds > 0) {
      toast("Helmet recharging: " + helmetCooldownRounds + " rounds left");
    } else {
      helmetActive = true;
      helmetCooldownRounds = 2;
      equipment.helmet = "helmet_invisibility";
      updateEquipHUD();
      toast("You vanish from sight...");
    }
  }

  if (k === "i") openInventory();

  if (e.key === "9") unlockAll();

  const num = parseInt(e.key);
  if (!isNaN(num)) {
    if (num >= 1 && num <= 6) {
      const target = num * 5;
      levelJumpUsed = true;
      toast("Jumped to boss level " + target);
      startLevel(target);
    } else if (num === 7) {
      levelJumpUsed = true;
      toast("Jumped to final battle (35)");
      startLevel(35);
    }
  }

  if (k === "h" && gameState === "playing") {
    useEquippedTimeCharm();
  }
});

addEventListener("keyup", e => {
  keys[e.key.toLowerCase()] = false;
});

canvas.addEventListener("wheel", e => {
  if (gameState === "inventory") {
    e.preventDefault();
    inventoryScroll += e.deltaY * 0.5;
    inventoryScroll = Math.max(0, Math.min(inventoryScroll, maxInventoryScroll));
  }
}, { passive: false });

/* =========================================================
   Equip helper
   ========================================================= */
function equipWeapon(key) {
  currentWeapon = key;
  equipment.weapon = key;
  applyEquipmentEffects();
  updateEquipHUD();
  toast(itemData[key].name + " equipped");
}

/* =========================================================
   Projectile updates (arrows, flames, lightning, etc.)
   ========================================================= */
function updateHomingArrow(p, dt) {
  if (!boss) return;

  const targetX = boss.x + boss.w / 2;
  const targetY = boss.y + boss.h / 2;

  const dx = targetX - p.x;
  const dy = targetY - p.y;
  const dist = Math.hypot(dx, dy);

  if (dist > 0) {
    const speed = 260;
    p.vx = (dx / dist) * speed;
    p.vy = (dy / dist) * speed;
  }
}

/* =========================================================
   Giant Wave (Trident Ultimate)
   ========================================================= */
function summonWave(dmg) {
  const wave = {
    x: player.x + player.w,
    y: H / 2,
    w: 40,
    h: 40,
    vx: 260,
    growthRateW: 180,
    growthRateH: 140,
    maxHeight: 260,
    alive: true,
    damage: dmg * 3
  };

  waves.push(wave);
  toast("A mighty wave surges forward!");
}

/* =========================================================
   Lightning Storm (Lightning Ultimate)
   ========================================================= */
function summonLightningStorm(dmg) {
  for (let i = 0; i < 6; i++) {
    const x = Math.random() * (W - 40);
    lightningStrikes.push({
      x,
      y: 0,
      w: 20,
      h: H,
      life: 0.35,
      damage: dmg * 1.5
    });
  }
  toast("Lightning storm unleashed!");
}

/* =========================================================
   Inferno (Torch Ultimate)
   ========================================================= */
function summonInferno(dmg) {
  infernos.push({
    x: player.x + player.w + 40,
    y: player.y + player.h / 2,
    radius: 10,
    maxRadius: 160,
    growthRate: 180,
    alive: true,
    damage: dmg * 1.2
  });

  toast("Inferno ignited!");
}

/* =========================================================
   Rain of Arrows (Artemis Bow Ultimate)
   ========================================================= */
function summonRainOfArrows(dmg) {
  const count = 7;
  const spread = 260;

  for (let i = 0; i < count; i++) {
    const offset = (Math.random() - 0.5) * spread;
    projectiles.push({
      x: player.x + player.w + offset,
      y: -20,
      w: 12,
      h: 20,
      vx: 0,
      vy: 500,
      damage: dmg,
      type: "arrow",
      fromEnemy: false
    });
  }

  toast("Artemis rains arrows from above!");
}

/* =========================================================
   Projectile update loop
   ========================================================= */
function updateProjectiles(dt) {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];

    if (p.type === "artemisArrow" && !p.fromEnemy) {
      updateHomingArrow(p, dt);
    }

    p.x += p.vx * dt;
    if (p.vy !== undefined) p.y += p.vy * dt;

    if (p.x > W || p.x + p.w < 0 || p.y > H || p.y + p.h < -40) {
      projectiles.splice(i, 1);
      continue;
    }

    if (p.fromEnemy) {
      if (!helmetActive && collides(player, p)) {
        const dmg = p.damage || scaleEnemyDamage(5);
        applyObstacleDamage(dmg, "Hit by enemy arrow!");
        projectiles.splice(i, 1);
        continue;
      }
      continue;
    }

    if (boss && collides(p, boss)) {
      boss.hp -= p.damage;
      toast("Projectile hit " + boss.name + "!");
      projectiles.splice(i, 1);
      if (boss.hp <= 0) {
        toast(boss.name + " defeated!");
        lastBossBeaten = currentLevel;
        drachma += 20;
        updateDrachmaHUD();
        maybeSpawnWeaponDropAt(boss.x + boss.w / 2, boss.y);
        boss = null;
      }
      continue;
    }

    let hitEnemy = false;
    for (let j = enemies.length - 1; j >= 0; j--) {
      const e = enemies[j];
      if (!collides(p, e)) continue;

      if (e.type === "shield") {
        if (p.vx > 0 && p.x <= e.x + e.w && p.x >= e.x) {
          toast("Arrow deflected by shield bearer!");
          projectiles.splice(i, 1);
          hitEnemy = true;
          break;
        }
      }

      e.hp -= p.damage;
      projectiles.splice(i, 1);
      hitEnemy = true;

      if (e.hp <= 0) {
        drachma += 3;
        updateDrachmaHUD();
        maybeSpawnWeaponDropAt(e.x + e.w / 2, e.y);
        enemies.splice(j, 1);
      }
      break;
    }
    if (hitEnemy) continue;

    if (currentLevel === 35 && greekShips.length > 0) {
      let hitShip = false;
      for (let j = greekShips.length - 1; j >= 0; j--) {
        const ship = greekShips[j];
        const shipBox = {
          x: ship.x,
          y: ship.y - ship.h,
          w: ship.w,
          h: ship.h
        };

        if (collides(p, shipBox)) {
          ship.hp -= p.damage;
          projectiles.splice(i, 1);
          hitShip = true;

          if (ship.hp <= 0) {
            drachma += 20;
            updateDrachmaHUD();
            maybeSpawnWeaponDropAt(ship.x + ship.w / 2, ship.y - ship.h);
            greekShips.splice(j, 1);
          }
          break;
        }
      }

      if (hitShip) continue;
    }
  }
}

/* =========================================================
   Wave update loop
   ========================================================= */
function updateWaves(dt) {
  for (let i = waves.length - 1; i >= 0; i--) {
    const wave = waves[i];

    if (!wave.alive) {
      waves.splice(i, 1);
      continue;
    }

    wave.x += wave.vx * dt;
    wave.w += wave.growthRateW * dt;
    wave.h += wave.growthRateH * dt;

    if (wave.h > wave.maxHeight) wave.h = wave.maxHeight;

    const waveCenterY = H / 2;
    wave.y = waveCenterY - wave.h / 2;

    const hitbox = {
      x: wave.x,
      y: wave.y,
      w: wave.w,
      h: wave.h
    };

    if (boss && collides(hitbox, boss)) {
      boss.hp -= wave.damage;
      toast("Wave smashes " + boss.name + "!");
      if (boss.hp <= 0) {
        toast(boss.name + " defeated by the wave!");
        lastBossBeaten = currentLevel;
        drachma += 20;
        updateDrachmaHUD();
        maybeSpawnWeaponDropAt(boss.x + boss.w / 2, boss.y);
        boss = null;
      }
    }

    for (let j = enemies.length - 1; j >= 0; j--) {
      const e = enemies[j];
      if (!collides(hitbox, e)) continue;
      e.hp -= wave.damage;
      if (e.hp <= 0) {
        drachma += 3;
        updateDrachmaHUD();
        maybeSpawnWeaponDropAt(e.x + e.w / 2, e.y);
        enemies.splice(j, 1);
      }
    }

    if (currentLevel === 35 && greekShips.length > 0) {
      for (let j = greekShips.length - 1; j >= 0; j--) {
        const ship = greekShips[j];
        const shipBox = {
          x: ship.x,
          y: ship.y - ship.h,
          w: ship.w,
          h: ship.h
        };

        if (collides(hitbox, shipBox)) {
          ship.hp -= wave.damage;

          if (ship.hp <= 0) {
            drachma += 20;
            updateDrachmaHUD();
            maybeSpawnWeaponDropAt(ship.x + ship.w / 2, ship.y - ship.h);
            greekShips.splice(j, 1);
          }
        }
      }
    }

    if (wave.x > W && wave.w > W * 1.2) {
      wave.alive = false;
    }
  }
}

/* =========================================================
   Lightning strike update loop
   ========================================================= */
function updateLightning(dt) {
  for (let i = lightningStrikes.length - 1; i >= 0; i--) {
    const strike = lightningStrikes[i];
    strike.life -= dt;

    if (strike.life <= 0) {
      lightningStrikes.splice(i, 1);
      continue;
    }

    const box = {
      x: strike.x,
      y: strike.y,
      w: strike.w,
      h: strike.h
    };

    if (boss && collides(box, boss)) {
      boss.hp -= strike.damage;

      if (boss.hp <= 0) {
        toast(boss.name + " blasted by lightning!");
        lastBossBeaten = currentLevel;
        drachma += 20;
        updateDrachmaHUD();
        maybeSpawnWeaponDropAt(boss.x + boss.w / 2, boss.y);
        boss = null;
      }
    }

    for (let j = enemies.length - 1; j >= 0; j--) {
      const e = enemies[j];
      if (!collides(box, e)) continue;
      e.hp -= strike.damage;
      if (e.hp <= 0) {
        drachma += 3;
        updateDrachmaHUD();
        maybeSpawnWeaponDropAt(e.x + e.w / 2, e.y);
        enemies.splice(j, 1);
      }
    }

    if (currentLevel === 35 && greekShips.length > 0) {
      for (let j = greekShips.length - 1; j >= 0; j--) {
        const ship = greekShips[j];
        const shipBox = {
          x: ship.x,
          y: ship.y - ship.h,
          w: ship.w,
          h: ship.h
        };

        if (collides(box, shipBox)) {
          ship.hp -= strike.damage;

          if (ship.hp <= 0) {
            drachma += 20;
            updateDrachmaHUD();
            maybeSpawnWeaponDropAt(ship.x + ship.w / 2, ship.y - ship.h);
            greekShips.splice(j, 1);
          }
        }
      }
    }
  }
}

/* =========================================================
   Inferno update loop
   ========================================================= */
function updateInfernos(dt) {
  for (let i = infernos.length - 1; i >= 0; i--) {
    const inf = infernos[i];

    if (!inf.alive) {
      infernos.splice(i, 1);
      continue;
    }

    inf.radius += inf.growthRate * dt;

    if (inf.radius >= inf.maxRadius) {
      inf.alive = false;
    }

    const r2 = inf.radius * inf.radius;

    function inside(obj) {
      const cx = obj.x + obj.w / 2;
      const cy = obj.y + obj.h / 2;
      const dx = cx - inf.x;
      const dy = cy - inf.y;
      return dx * dx + dy * dy <= r2;
    }

    if (boss && inside(boss)) {
      boss.hp -= inf.damage;

      if (boss.hp <= 0) {
        toast(boss.name + " consumed by flames!");
        lastBossBeaten = currentLevel;
        drachma += 20;
        updateDrachmaHUD();
        maybeSpawnWeaponDropAt(boss.x + boss.w / 2, boss.y);
        boss = null;
      }
    }

    for (let j = enemies.length - 1; j >= 0; j--) {
      const e = enemies[j];
      if (!inside(e)) continue;
      e.hp -= inf.damage;
      if (e.hp <= 0) {
        drachma += 3;
        updateDrachmaHUD();
        maybeSpawnWeaponDropAt(e.x + e.w / 2, e.y);
        enemies.splice(j, 1);
      }
    }

    if (currentLevel === 35 && greekShips.length > 0) {
      for (let j = greekShips.length - 1; j >= 0; j--) {
        const ship = greekShips[j];
        const shipBox = {
          x: ship.x,
          y: ship.y - ship.h,
          w: ship.w,
          h: ship.h
        };

        if (inside(shipBox)) {
          ship.hp -= inf.damage;

          if (ship.hp <= 0) {
            drachma += 20;
            updateDrachmaHUD();
            maybeSpawnWeaponDropAt(ship.x + ship.w / 2, ship.y - ship.h);
            greekShips.splice(j, 1);
          }
        }
      }
    }
  }
}

/* =========================================================
   Inventory drawing helpers
   ========================================================= */
function drawItemIcon(id, x, y, size) {
  const img = itemImages[id];

  if (img && img.complete && img.naturalWidth > 0) {
    ctx.drawImage(img, x, y, size, size);
    return;
  }

  ctx.save();
  switch (id) {
    case "helmet_invisibility": ctx.fillStyle = "#bbbbbb"; break;
    case "sword": ctx.fillStyle = "#cccccc"; break;
    case "axe": ctx.fillStyle = "#ff5555"; break;
    case "bow": ctx.fillStyle = "#ffaa00"; break;
    case "artemisBow": ctx.fillStyle = "#dddddd"; break;
    case "spear": ctx.fillStyle = "#ffffff"; break;
    case "trident": ctx.fillStyle = "#55ff55"; break;
    case "lightning": ctx.fillStyle = "#ffff55"; break;
    case "torch": ctx.fillStyle = "#ff8844"; break;
    case "shield_item": ctx.fillStyle = "#88ffff"; break;
    case "chaos_charm": ctx.fillStyle = "#ff00ff"; break;
    case "blood_charm": ctx.fillStyle = "#aa0000"; break;
    case "time_skip_charm": ctx.fillStyle = "#66ccff"; break;
    case "time_slow_charm": ctx.fillStyle = "#6699ff"; break;
    case "time_rewind_charm": ctx.fillStyle = "#cc66ff"; break;
    case "time_freeze_charm": ctx.fillStyle = "#99ffff"; break;
    case "mount_lion": ctx.fillStyle = "#ffcc66"; break;
    case "mount_pegasus": ctx.fillStyle = "#ccccff"; break;
    case "mount_bull": ctx.fillStyle = "#aa6633"; break;
    case "mount_horse": ctx.fillStyle = "#cc9966"; break;
    case "chariot_normal": ctx.fillStyle = "#999999"; break;
    case "chariot_helios": ctx.fillStyle = "#ffdd55"; break;
    case "potion_strength":  ctx.fillStyle = "#ff4444"; break;
    case "potion_swiftness": ctx.fillStyle = "#44bbff"; break;
    case "potion_fortitude": ctx.fillStyle = "#66ff66"; break;
    case "potion_aegis":     ctx.fillStyle = "#ddddff"; break;
    default: ctx.fillStyle = "#cccccc"; break;
  }
  ctx.fillRect(x, y, size, size);
  ctx.restore();
}

/* =========================================================
   Inventory UI
   ========================================================= */
function drawInventoryUI() {
  ctx.fillStyle = "rgba(0,0,0,0.7)";
  ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = "#222";
  ctx.fillRect(invUI.x, invUI.y, invUI.w, invUI.h);
  ctx.strokeStyle = "#aaa";
  ctx.lineWidth = 2;
  ctx.strokeRect(invUI.x, invUI.y, invUI.w, invUI.h);

  ctx.fillStyle = "#fff";
  ctx.font = "20px sans-serif";
  ctx.fillText("Inventory (I to close)", invUI.x + 20, invUI.y + 30);

  const slotSize = 56;

  const invX = invUI.x + invUI.padding;
  const invY = invUI.y + invUI.padding + 20;
  const INVENTORY_AREA_WIDTH = 320;

  const equipGap = 20;
  const equipXStart = invX + INVENTORY_AREA_WIDTH + equipGap;
  const equipYStart = invY + 20;

  const equipSlots = [
    { key: "weapon",  label: "Weapon",  row: 0, col: 0 },
    { key: "helmet",  label: "Helmet",  row: 0, col: 1 },
    { key: "shield",  label: "Shield",  row: 0, col: 2 },
    { key: "charm",   label: "Charm",   row: 1, col: 0 },
    { key: "mount",   label: "Mount",   row: 1, col: 1 },
    { key: "chariot", label: "Chariot", row: 1, col: 2 }
  ];

  ctx.font = "14px sans-serif";
  const colSpacing = slotSize + 16;
  const rowSpacing = slotSize + 24;

  equipSlots.forEach(slot => {
    const sx = equipXStart + slot.col * colSpacing;
    const sy = equipYStart + slot.row * rowSpacing;

    ctx.strokeStyle = "#888";
    ctx.strokeRect(sx, sy, slotSize, slotSize);

    ctx.fillStyle = "#fff";
    ctx.fillText(slot.label, sx, sy + slotSize + 16);

    const itemId = equipment[slot.key];
    if (itemId) {
      drawItemIcon(itemId, sx + 4, sy + 4, slotSize - 8);
    }
  });

  const gridInvY = invY + 80;
  const visibleHeight = invUI.h - (invUI.padding + 80 + 24);
  const totalHeight = INVENTORY_ROWS * invUI.cellSize;
  maxInventoryScroll = Math.max(0, totalHeight - visibleHeight);
  inventoryScroll = Math.max(0, Math.min(inventoryScroll, maxInventoryScroll));

  ctx.save();
  ctx.beginPath();
  ctx.rect(invX, gridInvY, INVENTORY_AREA_WIDTH, visibleHeight);
  ctx.clip();

  for (let row = 0; row < INVENTORY_ROWS; row++) {
    for (let col = 0; col < INVENTORY_COLS; col++) {
      const idx = row * INVENTORY_COLS + col;
      const cellX = invX + col * invUI.cellSize;
      const cellY = gridInvY + row * invUI.cellSize - inventoryScroll;

      if (cellY > gridInvY + visibleHeight || cellY + invUI.cellSize < gridInvY) continue;

      ctx.strokeStyle = "#555";
      ctx.strokeRect(cellX, cellY, invUI.cellSize, invUI.cellSize);

      const item = inventory[idx];
      if (item) {
        if (
          draggingItem &&
          draggingItem.source === "inventory" &&
          draggingItem.index === idx
        ) {
          continue;
        }
        drawItemIcon(item.id, cellX + 4, cellY + 4, invUI.cellSize - 8);
      }
    }
  }

  ctx.restore();

  if (maxInventoryScroll > 0) {
    const barX = invX + INVENTORY_AREA_WIDTH - 10;
    const barY = gridInvY;
    const barW = 8;
    const barH = visibleHeight;

    ctx.fillStyle = "#333";
    ctx.fillRect(barX, barY, barW, barH);

    const handleH = Math.max(20, barH * (visibleHeight / totalHeight));
    const handleY = barY + (inventoryScroll / maxInventoryScroll) * (barH - handleH);

    ctx.fillStyle = "#888";
    ctx.fillRect(barX, handleY, barW, handleH);
  }

  if (draggingItem) {
    const size = 48;
    drawItemIcon(draggingItem.itemId, mouseX - size / 2, mouseY - size / 2, size);
  }
}

/* =========================================================
   Inventory drag & drop
   ========================================================= */
canvas.addEventListener("mousedown", e => {
  if (gameState !== "inventory") return;

  const rect = canvas.getBoundingClientRect();
  mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
  mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);

  const invX = invUI.x + invUI.padding;
  const invY = invUI.y + invUI.padding + 20;
  const INVENTORY_AREA_WIDTH = 320;
  const gridInvY = invY + 80;
  const visibleHeight = invUI.h - (invUI.padding + 80 + 24);

  for (let row = 0; row < INVENTORY_ROWS; row++) {
    for (let col = 0; col < INVENTORY_COLS; col++) {
      const idx = row * INVENTORY_COLS + col;
      const cellX = invX + col * invUI.cellSize;
      const cellY = gridInvY + row * invUI.cellSize - inventoryScroll;

      if (cellY > gridInvY + visibleHeight || cellY + invUI.cellSize < gridInvY) continue;

      if (
        mouseX >= cellX &&
        mouseX <= cellX + invUI.cellSize &&
        mouseY >= cellY &&
        mouseY <= cellY + invUI.cellSize
      ) {
        const item = inventory[idx];
        if (item) {
          draggingItem = {
            source: "inventory",
            index: idx,
            itemId: item.id
          };
          dragOffsetX = mouseX - cellX;
          dragOffsetY = mouseY - cellY;
        }
      }
    }
  }

  const equipGap = 20;
  const equipXStart = invX + INVENTORY_AREA_WIDTH + equipGap;
  const equipYStart = invY + 20;
  const slotSize = 56;
  const colSpacing = slotSize + 16;
  const rowSpacing = slotSize + 24;

  const equipSlots = [
    { key: "weapon",  row: 0, col: 0 },
    { key: "helmet",  row: 0, col: 1 },
    { key: "shield",  row: 0, col: 2 },
    { key: "charm",   row: 1, col: 0 },
    { key: "mount",   row: 1, col: 1 },
    { key: "chariot", row: 1, col: 2 }
  ];

  equipSlots.forEach(slot => {
    const sx = equipXStart + slot.col * colSpacing;
    const sy = equipYStart + slot.row * rowSpacing;

    if (
      mouseX >= sx &&
      mouseX <= sx + slotSize &&
      mouseY >= sy &&
      mouseY <= sy + slotSize
    ) {
      const itemId = equipment[slot.key];
      if (itemId) {
        draggingItem = {
          source: "slot",
          slotKey: slot.key,
          itemId
        };
        dragOffsetX = mouseX - sx;
        dragOffsetY = mouseY - sy;
      }
    }
  });
});

canvas.addEventListener("mousemove", e => {
  if (gameState !== "inventory") return;

  const rect = canvas.getBoundingClientRect();
  mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
  mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
});

canvas.addEventListener("mouseup", e => {
  if (gameState !== "inventory") return;
  if (!draggingItem) return;

  const rect = canvas.getBoundingClientRect();
  mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
  mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);

  const draggedId = draggingItem.itemId;
  const data = itemData[draggedId];

  let placed = false;

  const invX = invUI.x + invUI.padding;
  const invY = invUI.y + invUI.padding + 20;
  const INVENTORY_AREA_WIDTH = 320;
  const gridInvY = invY + 80;
  const visibleHeight = invUI.h - (invUI.padding + 80 + 24);

  const equipGap = 20;
  const equipXStart = invX + INVENTORY_AREA_WIDTH + equipGap;
  const equipYStart = invY + 20;
  const slotSize = 56;
  const colSpacing = slotSize + 16;
  const rowSpacing = slotSize + 24;

  const equipSlots = [
    { key: "weapon",  row: 0, col: 0 },
    { key: "helmet",  row: 0, col: 1 },
    { key: "shield",  row: 0, col: 2 },
    { key: "charm",   row: 1, col: 0 },
    { key: "mount",   row: 1, col: 1 },
    { key: "chariot", row: 1, col: 2 }
  ];

  equipSlots.forEach(slot => {
    const sx = equipXStart + slot.col * colSpacing;
    const sy = equipYStart + slot.row * rowSpacing;

    if (
      mouseX >= sx &&
      mouseX <= sx + slotSize &&
      mouseY >= sy &&
      mouseY <= sy + slotSize
    ) {
      if (data && data.slot === slot.key) {
        if (draggingItem.source === "inventory") {
          inventory[draggingItem.index] = null;
        } else if (draggingItem.source === "slot") {
          equipment[draggingItem.slotKey] = null;
        }

        equipment[slot.key] = draggedId;
        applyEquipmentEffects();
        updateEquipHUD();
        placed = true;
      }
    }
  });

  if (!placed) {
    for (let row = 0; row < INVENTORY_ROWS; row++) {
      for (let col = 0; col < INVENTORY_COLS; col++) {
        const idx = row * INVENTORY_COLS + col;
        const cellX = invX + col * invUI.cellSize;
        const cellY = gridInvY + row * invUI.cellSize - inventoryScroll;

        if (cellY > gridInvY + visibleHeight || cellY + invUI.cellSize < gridInvY) continue;

        if (
          mouseX >= cellX &&
          mouseX <= cellX + invUI.cellSize &&
          mouseY >= cellY &&
          mouseY <= cellY + invUI.cellSize
        ) {
          if (draggingItem.source === "inventory") {
            const fromIdx = draggingItem.index;
            const temp = inventory[idx];
            inventory[idx] = { id: draggedId };
            inventory[fromIdx] = temp || null;
          } else if (draggingItem.source === "slot") {
            if (!inventory[idx]) {
              inventory[idx] = { id: draggedId };
              equipment[draggingItem.slotKey] = null;
              applyEquipmentEffects();
              updateEquipHUD();
            } else {
              const temp = inventory[idx];
              inventory[idx] = { id: draggedId };
              equipment[draggingItem.slotKey] = temp.id;
              applyEquipmentEffects();
              updateEquipHUD();
            }
          }
          placed = true;
        }
      }
    }
  }

  draggingItem = null;
});

/* =========================================================
   Inventory click-to-use for potions
   ========================================================= */
canvas.addEventListener("click", e => {
  if (gameState === "troy") {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);

    for (const b of troyBuildings) {
      if (
        mx >= b.x &&
        mx <= b.x + b.w &&
        my >= b.y &&
        my <= b.y + b.h
      ) {
        openBuilding(b.id);
        return;
      }
    }
    return;
  }

  if (gameState !== "inventory") return;

  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);

  const invX = invUI.x + invUI.padding;
  const invY = invUI.y + invUI.padding + 20;
  const gridInvY = invY + 80;
  const INVENTORY_AREA_WIDTH = 320;
  const visibleHeight = invUI.h - (invUI.padding + 80 + 24);

  if (mx < invX || mx > invX + INVENTORY_AREA_WIDTH) return;
  if (my < gridInvY || my > gridInvY + visibleHeight) return;

  for (let row = 0; row < INVENTORY_ROWS; row++) {
    for (let col = 0; col < INVENTORY_COLS; col++) {
      const idx = row * INVENTORY_COLS + col;
      const cellX = invX + col * invUI.cellSize;
      const cellY = gridInvY + row * invUI.cellSize - inventoryScroll;

      if (cellY > gridInvY + visibleHeight || cellY + invUI.cellSize < gridInvY) continue;

      if (
        mx >= cellX &&
        mx <= cellX + invUI.cellSize &&
        my >= cellY &&
        my <= cellY + invUI.cellSize
      ) {
        const item = inventory[idx];
        if (!item) return;
        const data = itemData[item.id];
        if (data && data.type === "potion") {
          usePotion(item.id);
          inventory[idx] = null;
        }
        return;
      }
    }
  }
});

/* =========================================================
   Equipment effects
   ========================================================= */
function applyEquipmentEffects() {
  player.speed = BASE_SPEED;
  player.jump = BASE_JUMP;

  if (equipment.weapon) {
    currentWeapon = equipment.weapon;
  }

  shieldActive = equipment.shield === "shield_item";

  gearOwned.helmet = !!equipment.helmet;
  helmetActive = equipment.helmet === "helmet_invisibility";

  if (equipment.mount === "mount_lion") {
    player.speed *= 1.2;
  } else if (equipment.mount === "mount_pegasus") {
    player.speed *= 1.3;
    player.jump *= 1.2;
  } else if (equipment.mount === "mount_bull") {
    player.speed *= 1.1;
  } else if (equipment.mount === "mount_horse") {
    player.speed *= 1.4;
  }

  if (equipment.chariot === "chariot_normal") {
    player.speed *= 1.5;
  } else if (equipment.chariot === "chariot_helios") {
    player.speed *= 1.6;
  }

  player.speed *= potionSpeedMultiplier;
  player.jump *= potionJumpMultiplier;
}

/* =========================================================
   Inventory helpers
   ========================================================= */
function addItemToInventory(id) {
  for (let i = 0; i < INVENTORY_ROWS * INVENTORY_COLS; i++) {
    if (!inventory[i]) {
      inventory[i] = { id };
      return;
    }
  }
}

/* =========================================================
   Allies drawing
   ========================================================= */
function drawAllies() {
  allies.forEach(a => {
    const img = allyImages[a.type];
    if (img && img.complete && img.naturalWidth > 0) {
      ctx.drawImage(img, a.x, a.y, a.w, a.h);
    } else {
      if (a.type === "hector") ctx.fillStyle = "#66ff66";
      else if (a.type === "paris") ctx.fillStyle = "#66aaff";
      else if (a.type === "priam") ctx.fillStyle = "#ffcc66";
      else if (a.type === "helen") ctx.fillStyle = "#ff99ff";
      else ctx.fillStyle = "#88ff88";
      ctx.fillRect(a.x, a.y, a.w, a.h);
    }
  });
}

/* =========================================================
   Allies behavior
   ========================================================= */
function updateAllies(dt) {
  allies.forEach(a => {
    if (a.type === "hector") {
      if (boss) {
        if (a.x < boss.x - 40) a.x += a.vx * dt;

        const hitbox = { x: a.x, y: a.y, w: a.w, h: a.h };
        if (collides(hitbox, boss)) {
          boss.hp -= 0.5 * dt;
        }
      }

    } else if (a.type === "paris") {
      a.shootTimer -= dt;
      if (a.shootTimer <= 0 && boss) {
        a.shootTimer = 1.2;
        const px = a.x + a.w;
        const py = a.y + a.h / 2;
        spawnProjectile(px, py, 320, scalePlayerDamage(1), "arrow", false);
      }

    } else if (a.type === "priam") {
      a.healTimer -= dt;
      if (a.healTimer <= 0) {
        a.healTimer = 4;

        if (player.hp < player.maxHp) {
          player.hp = Math.min(player.maxHp, player.hp + 10);
          updateHPHUD();
          toast("Priam restores your strength!");
        }
      }

    } else if (a.type === "helen") {
      const targetX = player.x - 40;
      if (a.x < targetX) a.x += 120 * dt;
      if (a.x > targetX) a.x -= 120 * dt;
      a.y = player.y - 10;
    }
  });
}

/* =========================================================
   Allies spawn logic
   ========================================================= */
function spawnAlliesForLevel() {
  allies = [];

  let count = 0;
  if (currentLevel === 5 || currentLevel === 10) count = 1;
  if (currentLevel === 15 || currentLevel === 20) count = 2;
  if (currentLevel === 25 || currentLevel === 30) count = 3;

  if (count >= 1) {
    allies.push({
      type: "hector",
      x: 120,
      y: groundY - 32,
      w: 24,
      h: 32,
      vx: 140
    });
  }

  if (count >= 2) {
    allies.push({
      type: "paris",
      x: 80,
      y: groundY - 32,
      w: 20,
      h: 28,
      shootTimer: 0
    });
  }

  if (count >= 3) {
    allies.push({
      type: "priam",
      x: 60,
      y: groundY - 32,
      w: 20,
      h: 30,
      healTimer: 0
    });
  }

  if (currentLevel === 30) {
    allies.push({
      type: "helen",
      x: 40,
      y: groundY - 40,
      w: 18,
      h: 26
    });
  }
}

/* =========================================================
   Boss & ship spawning
   ========================================================= */
function spawnBoss(def) {
  boss = {
    name: def.name,
    hp: def.hp,
    x: W - 200,
    y: groundY - 120,
    w: 100,
    h: 100
  };
}

function spawnGreekShipsForFinal() {
  greekShips = [];
  const count = 3;

  for (let i = 0; i < count; i++) {
    greekShips.push({
      x: W + i * 180,
      y: seaY + 10,
      w: 140,
      h: 100,
      vx: -120,
      hp: 5
    });
  }
}

/* =========================================================
   Obstacles
   ========================================================= */
function spawnGroundObstacle() {
  if (atSea) {
    groundObstacles.push({
      x: W + 40,
      y: seaY - 50,
      w: 80,
      h: 50,
      speed: 200
    });
  } else {
    groundObstacles.push({
      x: W + 40,
      y: groundY - 30,
      w: 30,
      h: 30,
      speed: 200
    });
  }
}

function spawnFallingObstacle() {
  fallingObstacles.push({
    x: Math.random() * (W - 40),
    y: -40,
    w: 30,
    h: 30,
    vy: 200 + Math.random() * 200
  });
}

function spawnLowObstacle() {
  lowObstacles.push({
    x: W + 40,
    y: groundY - 20,
    w: 40,
    h: 20,
    speed: 200
  });
}

/* =========================================================
   Level start / reset
   ========================================================= */
function startLevel(n) {
  currentLevel = n;
  t = 0;
  gameState = "playing";
  finalVictory = false;
  atSea = (n >= 31 && n <= 35);

  potionDamageMultiplier = 1;
  potionSpeedMultiplier = 1;
  potionJumpMultiplier = 1;
  potionAegisActive = false;

  if (n !== 0 && helmetCooldownRounds > 0) {
    helmetCooldownRounds = Math.max(helmetCooldownRounds - 1, 0);
  }
  helmetActive = false;

  if (atSea) {
    boat = {
      x: W / 2 - 160,
      y: seaY,
      w: 320,
      h: 140
    };
    player.x = boat.x + boat.w / 2 - player.w / 2;
    player.y = boat.y - boat.h + 40;
  } else {
    boat = null;
    player.x = 40;
    player.y = groundY - player.h;
  }

  player.vx = 0;
  player.vy = 0;
  player.onGround = true;
  player.isRolling = false;
  player.rollTimer = 0;
  player.rollCooldown = 0;
  player.rollDir = 0;
  player.h = 32;
  player.maxHp = 100;
  player.hp = player.maxHp;
  updateHPHUD();

  boss = null;
  greekShips = [];
  groundObstacles = [];
  fallingObstacles = [];
  lowObstacles = [];
  groundSpawnTimer = 0;
  fallingSpawnTimer = 0;
  projectiles = [];
  weaponDrops = [];
  waves = [];
  lightningStrikes = [];
  infernos = [];
  allies = [];
  enemies = [];
  trojanSpawnTimer = 0;

  damageCooldown = 0;
  deathLock = false;
  levelComplete = false;
  specialCooldown = 0;
  timeSlowActive = false;
  timeFreezeActive = false;
  timeSlowTimer = 0;
  timeFreezeTimer = 0;

  document.getElementById("level").textContent = n;

  if (n === 0) {
    toast("Tutorial: Move (Arrows/WASD), Jump (Up/W), Attack (Space), Specials (J/K/L), Roll (Down), Switch (Q/W/E/R/T/Z/V/Y/X), Inventory (I), Time Charm (H), Shift to visit Troy.");
    return;
  }

  if (bossDefs[n]) {
    spawnBoss(bossDefs[n]);
    spawnAlliesForLevel();
  }

  if (n === 35) {
    spawnGreekShipsForFinal();
    toast("Final Battle: Defeat the Greek ships!");
  } else if (n >= 31 && n <= 34) {
    toast("Escape by sea! Avoid debris and arrows.");
  }

  spawnCoreEnemiesForLevel();

  applyEquipmentEffects();
  updateEquipHUD();
}

/* =========================================================
   Boss collision damage
   ========================================================= */
function applyBossCollisionDamage() {
  if (!boss) return;

  if (collides(player, boss)) {
    if (damageCooldown <= 0 && !deathLock) {
      if (helmetActive) {
        toast(boss.name + " cannot see you!");
        damageCooldown = 0.4;
        return;
      }

      if (potionAegisActive) {
        potionAegisActive = false;
        damageCooldown = 0.4;
        toast("Your Aegis potion negates the blow!");
        return;
      }

      const dmg = scaleEnemyDamage(15);

      if (shieldActive) {
        shieldActive = false;
        equipment.shield = null;
        applyEquipmentEffects();
        updateEquipHUD();
        damageCooldown = 0.4;
        toast("Shield blocked the hit!");
      } else {
        player.hp -= dmg;
        updateHPHUD();
        damageCooldown = 0.8;
        toast(boss.name + " hit you for " + dmg + " HP!");

        if (player.hp <= 0 && !deathLock) {
          deathLock = true;
          toast("You have fallen...");
          setTimeout(() => startLevel(currentLevel), 1200);
        }
      }
    }
  }
}

/* =========================================================
   Greek ship collision damage
   ========================================================= */
function applyShipCollisionDamage(ship) {
  const shipBox = {
    x: ship.x,
    y: ship.y - ship.h,
    w: ship.w,
    h: ship.h
  };
  if (collides(player, shipBox)) {
    if (damageCooldown <= 0 && !deathLock) {
      if (helmetActive) {
        toast("The ship cannot find you!");
        damageCooldown = 0.4;
        return;
      }

      if (potionAegisActive) {
        potionAegisActive = false;
        damageCooldown = 0.4;
        toast("Your Aegis potion negates the ram!");
        return;
      }

      const dmg = scaleEnemyDamage(15);

      if (shieldActive) {
        shieldActive = false;
        equipment.shield = null;
        applyEquipmentEffects();
        updateEquipHUD();
        damageCooldown = 0.4;
        toast("Shield blocked the ram!");
      } else {
        player.hp -= dmg;
        updateHPHUD();
        damageCooldown = 0.8;
        toast("Struck by a Greek ship for " + dmg + " HP!");

        if (player.hp <= 0 && !deathLock) {
          deathLock = true;
          toast("You have fallen...");
          setTimeout(() => startLevel(currentLevel), 1200);
        }
      }
    }
  }
}

/* =========================================================
   Obstacle damage
   ========================================================= */
function applyObstacleDamage(dmg, message) {
  if (damageCooldown <= 0 && !deathLock) {
    if (potionAegisActive) {
      potionAegisActive = false;
      damageCooldown = 0.4;
      toast("Your Aegis potion negates the hit!");
      return;
    }

    if (shieldActive) {
      shieldActive = false;
      equipment.shield = null;
      applyEquipmentEffects();
      updateEquipHUD();
      damageCooldown = 0.4;
      toast("Shield blocked the hit!");
    } else {
      player.hp -= dmg;
      updateHPHUD();
      damageCooldown = 0.8;
      toast(message);

      if (player.hp <= 0 && !deathLock) {
        deathLock = true;
        toast("You have fallen...");
        setTimeout(() => startLevel(lastBossBeaten || 0), 1200);
      }
    }
  }
}

/* =========================================================
   Main obstacle update logic
   ========================================================= */
function updateObstacles(dt) {
  const dmgGround = scaleEnemyDamage(5);
  const dmgFalling = scaleEnemyDamage(7);
  const dmgLow = scaleEnemyDamage(5);

  for (let i = groundObstacles.length - 1; i >= 0; i--) {
    const o = groundObstacles[i];
    o.x -= o.speed * dt;

    if (collides(player, o) && !helmetActive) {
      applyObstacleDamage(dmgGround, atSea ? "Struck floating debris!" : "Hit an obstacle!");
    }

    if (o.x + o.w < 0) {
      maybeSpawnWeaponDropAt(o.x, o.y);
      groundObstacles.splice(i, 1);
    }
  }

  for (let i = fallingObstacles.length - 1; i >= 0; i--) {
    const o = fallingObstacles[i];
    o.y += o.vy * dt;

    if (collides(player, o) && !helmetActive) {
      applyObstacleDamage(dmgFalling, atSea ? "Hit by Greek arrows!" : "Hit by falling debris!");
    }

    if (o.y > H) {
      maybeSpawnWeaponDropAt(o.x, o.y);
      fallingObstacles.splice(i, 1);
    }
  }

  for (let i = lowObstacles.length - 1; i >= 0; i--) {
    const o = lowObstacles[i];
    o.x -= o.speed * dt;

    if (!player.isRolling && collides(player, o) && !helmetActive) {
      applyObstacleDamage(dmgLow, "Hit a low obstacle!");
    }

    if (o.x + o.w < 0) {
      maybeSpawnWeaponDropAt(o.x, o.y);
      lowObstacles.splice(i, 1);
    }
  }
}

/* =========================================================
   Level progression
   ========================================================= */
function checkLevelProgress() {
  if (isBossLevel(currentLevel) && !levelComplete) {
    if (!boss && weaponDrops.length === 0 && enemies.length === 0) {
      levelComplete = true;
      toast("Boss defeated!");
      drachma += 10;
      updateDrachmaHUD();
      setTimeout(() => startLevel(currentLevel + 1), 1200);
    }
  }

  if (!isBossLevel(currentLevel) && !atSea && !levelComplete && currentLevel < 31) {
    if (player.x + player.w >= W - 5) {
      levelComplete = true;
      toast("Level Complete!");
      drachma += 10;
      updateDrachmaHUD();
      setTimeout(() => startLevel(currentLevel + 1), 800);
    }
  }

  if (atSea && currentLevel >= 31 && currentLevel <= 34 && !levelComplete) {
    if (player.x + player.w >= W - 5) {
      levelComplete = true;
      toast("You sail onward...");
      drachma += 10;
      updateDrachmaHUD();
      setTimeout(() => startLevel(currentLevel + 1), 800);
    }
  }

  if (currentLevel === 35 && !levelComplete && greekShips.length === 0) {
    levelComplete = true;
    finalVictory = true;
    lastBossBeaten = 35;
    toast("Well Done! You Escaped From Troy");
    gameState = "ended";
  }
}

/* =========================================================
   Weapon drop pickup logic
   ========================================================= */
function updateWeaponDrops() {
  for (let i = weaponDrops.length - 1; i >= 0; i--) {
    const drop = weaponDrops[i];

    if (collides(player, drop)) {
      const key = drop.weaponKey;

      if (key === "helmet") {
        if (!gearOwned.helmet) {
          gearOwned.helmet = true;
          addItemToInventory("helmet_invisibility");
          toast("You obtained the Helmet of Invisibility!");
        }
      } else if (key === "shield") {
        if (!weaponsOwned.shield) {
          weaponsOwned.shield = true;
          addItemToInventory("shield_item");
          toast("You obtained a Shield!");
        }
      } else if (
        key === "chaos_charm" ||
        key === "blood_charm" ||
        key === "time_skip_charm" ||
        key === "time_slow_charm" ||
        key === "time_rewind_charm" ||
        key === "time_freeze_charm" ||
        key === "mount_lion" ||
        key === "mount_pegasus" ||
        key === "mount_bull" ||
        key === "mount_horse" ||
        key === "chariot_normal" ||
        key === "chariot_helios"
      ) {
        const already = inventory.some(it => it && it.id === key);
        if (!already) {
          addItemToInventory(key);
          toast("You obtained the " + itemData[key].name + "!");
        }
      } else if (
        key === "potion_strength" ||
        key === "potion_swiftness" ||
        key === "potion_fortitude" ||
        key === "potion_aegis"
      ) {
        addItemToInventory(key);
        toast("You found a " + itemData[key].name + "!");
      } else {
        if (!weaponsOwned[key]) {
          weaponsOwned[key] = true;
          addItemToInventory(key);
          toast("You obtained the " + itemData[key].name + "!");
        }
      }

      weaponDrops.splice(i, 1);
    }
  }
}

/* =========================================================
   Title Screen Drawing
   ========================================================= */
function drawTitleScreen() {
  if (titleScreenImg.complete && titleScreenImg.naturalWidth > 0) {
    ctx.drawImage(titleScreenImg, 0, 0, W, H);
  } else {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = "#fff";
    ctx.font = "32px sans-serif";
    ctx.fillText("Escape From Troy", W / 2 - 140, H / 2);
    ctx.font = "18px sans-serif";
    ctx.fillText("Press Enter or Space to begin", W / 2 - 150, H / 2 + 40);
  }
}

/* =========================================================
   Drawing
   ========================================================= */
function drawBackground() {
  if (gameState === "troy") {
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, "#2b1b0a");
    g.addColorStop(1, "#4a2f14");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = "#3b2b1a";
    ctx.fillRect(0, groundY, W, 64);

    ctx.fillStyle = "#cfa96b";
    ctx.font = "22px sans-serif";
    ctx.fillText("Troy - Home Hub (Click buildings, Shift to return)", 40, 60);

troyBuildings.forEach(b => {
  const img = troyBuildingImages[b.id];

  if (img && img.complete && img.naturalWidth > 0) {
    ctx.drawImage(img, b.x, b.y, b.w, b.h);
  } else {
    // fallback if image missing
    ctx.fillStyle = "#663300";
    ctx.fillRect(b.x, b.y, b.w, b.h);
  }

  ctx.fillStyle = "#fff";
  ctx.font = "12px sans-serif";
  ctx.fillText(b.label, b.x + 4, b.y + b.h + 14);
});
    return;
  }

  if (atSea) {
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, "#031427");
    g.addColorStop(0.5, "#0a2640");
    g.addColorStop(1, "#05314a");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = "#0c4568";
    ctx.fillRect(0, seaY, W, H - seaY);
  } else {
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, "#071028");
    g.addColorStop(1, "#0b2a3a");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = "#3b2b1a";
    ctx.fillRect(0, groundY, W, 64);
  }
}

function drawBoat() {
  if (!atSea || !boat) return;

  if (boatImg.complete && boatImg.naturalWidth > 0) {
    ctx.drawImage(boatImg, boat.x, boat.y - boat.h, boat.w, boat.h);
  } else {
    ctx.fillStyle = "#704214";
    ctx.fillRect(boat.x, boat.y - boat.h, boat.w, boat.h);
  }
}

function drawPlayer() {
  if (aeneasImg.complete && aeneasImg.naturalWidth > 0) {
    ctx.drawImage(aeneasImg, player.x - 8, player.y - 8, player.w * 2.5, player.h * 2.5);
  } else {
    ctx.fillStyle = "#ccc";
    ctx.fillRect(player.x, player.y, player.w, player.h);
  }

  if (shieldActive) {
    ctx.strokeStyle = "#00ffff";
    ctx.lineWidth = 2;
    ctx.strokeRect(player.x - 4, player.y - 4, player.w + 8, player.h + 8);
  }

  if (helmetActive) {
    ctx.strokeStyle = "#ffff88";
    ctx.lineWidth = 2;
    ctx.strokeRect(player.x - 6, player.y - 6, player.w + 12, player.h + 12);
  }
}

function drawBoss() {
  if (!boss) return;
  const img = bossImages[boss.name];

  if (img && img.complete && img.naturalWidth > 0) {
    ctx.drawImage(img, boss.x, boss.y, boss.w, boss.h);
  } else {
    ctx.fillStyle = "#444";
    ctx.fillRect(boss.x, boss.y, boss.w, boss.h);
  }
}

function drawGreekShips() {
  if (currentLevel !== 35 || !greekShips.length) return;

  greekShips.forEach(ship => {
    const img = (greekShipImg.complete && greekShipImg.naturalWidth > 0)
      ? greekShipImg
      : boatImg;

    if (img && img.complete && img.naturalWidth > 0) {
      ctx.drawImage(img, ship.x, ship.y - ship.h, ship.w, ship.h);
    } else {
      ctx.fillStyle = "#883333";
      ctx.fillRect(ship.x, ship.y - ship.h, ship.w, ship.h);
    }
  });
}

function drawObstacles() {
  ctx.fillStyle = (currentLevel >= 31 && currentLevel <= 35) ? "#bba46a" : "#8b5a2b";
  groundObstacles.forEach(o => ctx.fillRect(o.x, o.y, o.w, o.h));

  ctx.fillStyle = (currentLevel >= 31 && currentLevel <= 35) ? "#e0e0ff" : "#4444aa";
  fallingObstacles.forEach(o => ctx.fillRect(o.x, o.y, o.w, o.h));

  ctx.fillStyle = "#aa8844";
  lowObstacles.forEach(o => ctx.fillRect(o.x, o.y, o.w, o.h));
}

function drawProjectiles() {
  projectiles.forEach(p => {
    if (p.type === "flame") ctx.fillStyle = "#ff8844";
    else if (p.type === "lightning") ctx.fillStyle = "#ffff55";
    else if (p.type === "arrow") ctx.fillStyle = p.fromEnemy ? "#ff6666" : "#ffdd55";
    else if (p.type === "artemisArrow") ctx.fillStyle = "#ddddff";
    else ctx.fillStyle = "#ffdd55";

    ctx.fillRect(p.x, p.y, p.w, p.h);
  });
}

function drawWeaponDrops() {
  weaponDrops.forEach(drop => {
    switch (drop.weaponKey) {
      case "bow":        ctx.fillStyle = "#ffaa00"; break;
      case "artemisBow": ctx.fillStyle = "#dddddd"; break;
      case "shield":     ctx.fillStyle = "#88ffff"; break;
      case "axe":        ctx.fillStyle = "#ff5555"; break;
      case "spear":      ctx.fillStyle = "#ffffff"; break;
      case "trident":    ctx.fillStyle = "#55ff55"; break;
      case "lightning":  ctx.fillStyle = "#ffff55"; break;
      case "torch":      ctx.fillStyle = "#ff8844"; break;
      case "helmet":     ctx.fillStyle = "#bbbbbb"; break;
      case "chaos_charm": ctx.fillStyle = "#ff00ff"; break;
      case "blood_charm": ctx.fillStyle = "#aa0000"; break;
      case "time_skip_charm": ctx.fillStyle = "#66ccff"; break;
      case "time_slow_charm": ctx.fillStyle = "#6699ff"; break;
      case "time_rewind_charm": ctx.fillStyle = "#cc66ff"; break;
      case "time_freeze_charm": ctx.fillStyle = "#99ffff"; break;
      case "mount_lion": ctx.fillStyle = "#ffcc66"; break;
      case "mount_pegasus": ctx.fillStyle = "#ccccff"; break;
      case "mount_bull": ctx.fillStyle = "#aa6633"; break;
      case "mount_horse": ctx.fillStyle = "#cc9966"; break;
      case "chariot_normal": ctx.fillStyle = "#999999"; break;
      case "chariot_helios": ctx.fillStyle = "#ffdd55"; break;
      case "potion_strength":  ctx.fillStyle = "#ff4444"; break;
      case "potion_swiftness": ctx.fillStyle = "#44bbff"; break;
      case "potion_fortitude": ctx.fillStyle = "#66ff66"; break;
      case "potion_aegis":     ctx.fillStyle = "#ddddff"; break;
      default:           ctx.fillStyle = "#cccccc"; break;
    }
    ctx.fillRect(drop.x, drop.y, drop.w, drop.h);
  });
}

function drawWaves() {
  waves.forEach(wave => {
    if (!wave.alive) return;
    if (waveImgLoaded && waveImg.complete && waveImg.naturalWidth > 0) {
      ctx.drawImage(waveImg, wave.x, wave.y, wave.w, wave.h);
    } else {
      const g = ctx.createLinearGradient(wave.x, wave.y, wave.x, wave.y + wave.h);
      g.addColorStop(0, "#88d9ff");
      g.addColorStop(0.5, "#3ba3ff");
      g.addColorStop(1, "#005b96");
      ctx.fillStyle = g;
      ctx.fillRect(wave.x, wave.y, wave.w, wave.h);
    }
  });
}

function drawLightningStrikes() {
  lightningStrikes.forEach(s => {
    ctx.fillStyle = "rgba(255,255,150,0.8)";
    ctx.fillRect(s.x, 0, s.w, H);
  });
}

function drawInfernos() {
  infernos.forEach(inf => {
    if (!inf.alive) return;
    const g = ctx.createRadialGradient(
      inf.x, inf.y, inf.radius * 0.1,
      inf.x, inf.y, inf.radius
    );
    g.addColorStop(0, "rgba(255,255,200,0.8)");
    g.addColorStop(0.4, "rgba(255,180,80,0.7)");
    g.addColorStop(1, "rgba(140,30,0,0.0)");
    ctx.fillStyle = g;

    ctx.beginPath();
    ctx.arc(inf.x, inf.y, inf.radius, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawEnemies() {
  enemies.forEach(e => {
    const img = enemyImages[e.type];
    if (img && img.complete && img.naturalWidth > 0) {
      ctx.drawImage(img, e.x, e.y, e.w, e.h);
    } else {
      if (e.type === "foot") ctx.fillStyle = "#ffcc99";
      else if (e.type === "archer") ctx.fillStyle = "#99ccff";
      else if (e.type === "shield") ctx.fillStyle = "#cccccc";
      else if (e.type === "spear") ctx.fillStyle = "#ffe066";
      else ctx.fillStyle = "#ffffff";
      ctx.fillRect(e.x, e.y, e.w, e.h);
    }
  });
}

function drawLevelJumpWarning() {
  if (!levelJumpUsed) return;
  ctx.fillStyle = "yellow";
  ctx.font = "24px sans-serif";
  ctx.fillText("LEVEL JUMP ENABLED", 20, 40);
}

function drawFinalVictory() {
  if (!finalVictory) return;

  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = "#fff";
  ctx.font = "40px sans-serif";
  ctx.textAlign = "center";
  ctx.fillText("Well Done!", W / 2, H / 2 - 20);
  ctx.fillText("You Escaped From Troy", W / 2, H / 2 + 30);
  ctx.textAlign = "left";
}

/* =========================================================
   Main draw
   ========================================================= */
function draw() {
  ctx.clearRect(0, 0, W, H);

  if (gameState === "title") {
    drawTitleScreen();
    return;
  }

  drawBackground();

  if (gameState !== "troy") {
    drawBoat();
    drawPlayer();
    drawBoss();
    drawGreekShips();
    drawObstacles();
    drawProjectiles();
    drawWeaponDrops();
    drawWaves();
    drawLightningStrikes();
    drawInfernos();
    drawEnemies();
    drawAllies();
    drawLevelJumpWarning();
    drawFinalVictory();
  } else {
    drawPlayer();
  }

  if (gameState === "inventory") {
    drawInventoryUI();
  }

  document.getElementById("time").textContent = t.toFixed(1);
}

/* =========================================================
   Main update loop
   ========================================================= */
function update(now) {
  const rawDt = (now - last) / 1000;
  last = now;

  if (damageCooldown > 0) damageCooldown -= rawDt;
  if (specialCooldown > 0) specialCooldown -= rawDt;

  if (timeSlowActive) {
    timeSlowTimer -= rawDt;
    if (timeSlowTimer <= 0) {
      timeSlowActive = false;
      toast("Time returns to normal.");
    }
  }

  if (timeFreezeActive) {
    timeFreezeTimer -= rawDt;
    if (timeFreezeTimer <= 0) {
      timeFreezeActive = false;
      toast("Time flows again.");
    }
  }

  const worldDt = timeFreezeActive
    ? 0
    : (timeSlowActive ? rawDt * 0.5 : rawDt);

  if (gameState === "playing" || gameState === "troy") {
    t += rawDt;

    updatePlayer(rawDt);

    if (atSea && boat && currentLevel >= 31 && currentLevel <= 34 && gameState === "playing") {
      boat.x += 60 * worldDt;
    }

    if (atSea && boat && currentLevel >= 31 && currentLevel <= 35 && gameState === "playing") {
      if (player.x < boat.x) player.x = boat.x;
      if (player.x + player.w > boat.x + boat.w) player.x = boat.x + boat.w - player.w;

      const deckY = boat.y - boat.h + 40;
      if (player.y > deckY) {
        player.y = deckY;
        player.vy = 0;
        player.onGround = true;
      }
    }

    if (gameState === "playing") {
      updateProjectiles(worldDt);
      updateWaves(worldDt);
      updateLightning(worldDt);
      updateInfernos(worldDt);
      updateObstacles(worldDt);
      updateEnemies(worldDt);
      updateAllies(worldDt);
      updateWeaponDrops();

      applyBossCollisionDamage();

      if (boss && boss.name === "Trojan Horse") {
        trojanSpawnTimer += worldDt;
        if (trojanSpawnTimer > 3) {
          trojanSpawnTimer = 0;
          const spawnTypes = ["foot", "archer", "shield", "spear"];
          for (let i = 0; i < 3; i++) {
            const type = spawnTypes[Math.floor(Math.random() * spawnTypes.length)];
            spawnEnemy(type, boss.x - 40 - i * 30, groundY - 32);
          }
          toast("The Trojan Horse disgorges Greek soldiers!");
        }
      }

      if (currentLevel === 35) {
        for (let i = greekShips.length - 1; i >= 0; i--) {
          const ship = greekShips[i];
          ship.x += ship.vx * worldDt;

          applyShipCollisionDamage(ship);

          if (ship.x + ship.w < 0) {
            greekShips.splice(i, 1);
          }
        }
      }

      if (!isBossLevel(currentLevel) && currentLevel !== 35) {
        groundSpawnTimer += worldDt;
        if (groundSpawnTimer > 2) {
          if (Math.random() < 0.25) spawnLowObstacle();
          else spawnGroundObstacle();
          groundSpawnTimer = 0;
        }

        fallingSpawnTimer += worldDt;
        if (fallingSpawnTimer > 1.5) {
          spawnFallingObstacle();
          fallingSpawnTimer = 0;
        }
      }

      checkLevelProgress();
    }
  }

  draw();
  requestAnimationFrame(update);
}

/* =========================================================
   Equip HUD
   ========================================================= */
function updateEquipHUD() {
  const hud = document.getElementById("equipHUD");

  const w = equipment.weapon ? itemData[equipment.weapon].name : "None";
  const h = equipment.helmet ? itemData[equipment.helmet].name : "None";
  const s = equipment.shield ? itemData[equipment.shield].name : "None";
  const c = equipment.charm ? itemData[equipment.charm].name : "None";
  const m = equipment.mount ? itemData[equipment.mount].name : "None";
  const ch = equipment.chariot ? itemData[equipment.chariot].name : "None";

  hud.textContent = `Weapon: ${w} | Helmet: ${h} | Shield: ${s} | Charm: ${c} | Mount: ${m} | Chariot: ${ch}`;
}

/* =========================================================
   Inventory open/close
   ========================================================= */
function openInventory() {
  if (gameState === "playing" || gameState === "troy") {
    gameState = "inventory";
    inventoryScroll = 0;
    toast("Inventory opened");
  }
}

function closeInventory() {
  if (gameState === "inventory") {
    gameState = "playing";
    draggingItem = null;
    toast("Inventory closed");
  }
}

/* =========================================================
   Cheat unlock
   ========================================================= */
function unlockAll() {
  weaponsOwned = {
    sword: true,
    axe: true,
    bow: true,
    artemisBow: true,
    spear: true,
    trident: true,
    shield: true,
    lightning: true,
    torch: true
  };

  gearOwned.helmet = true;
  shieldActive = true;

  const allIds = [
    "sword","axe","bow","artemisBow","spear","trident","lightning","torch",
    "shield_item","helmet_invisibility","chaos_charm","blood_charm",
    "time_skip_charm","time_slow_charm","time_rewind_charm","time_freeze_charm",
    "mount_lion","mount_pegasus","mount_bull","mount_horse",
    "chariot_normal","chariot_helios",
    "potion_strength","potion_swiftness","potion_fortitude","potion_aegis"
  ];

  for (let i = 0; i < allIds.length; i++) {
    addItemToInventory(allIds[i]);
  }

  drachma += 999;
  updateDrachmaHUD();

  toast("All weapons, mounts, chariots, charms, and potions activated");
}

/* =========================================================
   Toast helper
   ========================================================= */
function toast(msg) {
  document.getElementById("msg").textContent = msg;
}

/* =========================================================
   Difficulty stub
   ========================================================= */
function setDifficulty(d) {
  toast("Difficulty set to " + d);
}

/* =========================================================
   Enemy spawning stub
   ========================================================= */
function spawnCoreEnemiesForLevel() {
  enemies = [];
  if (!isBossLevel(currentLevel) && currentLevel > 0 && currentLevel < 31) {
    for (let i = 0; i < 5; i++) {
      spawnEnemy("foot", 200 + i * 80, groundY - 32);
    }
  }
}

function spawnEnemy(type, x, y) {
  enemies.push({
    type,
    x,
    y,
    w: 24,
    h: 32,
    hp: 4,
    vx: -60
  });
}

function updateEnemies(dt) {
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    e.x += e.vx * dt;
    if (e.x + e.w < 0) {
      enemies.splice(i, 1);
    }
  }
}

function maybeSpawnWeaponDropAt(x, y) {
  // simple random drop
  if (Math.random() < 0.2) {
    weaponDrops.push({
      x,
      y,
      w: 20,
      h: 20,
      weaponKey: "potion_strength"
    });
  }
}

function isBossLevel(n) {
  return !!bossDefs[n];
}

/* =========================================================
   TROY BUILDINGS & SHOPS
   ========================================================= */
const shopOverlay = document.getElementById("shopOverlay");
const shopGrid = document.getElementById("shopGrid");
const shopTitle = document.getElementById("shopTitle");
const shopCloseBtn = document.getElementById("shopCloseBtn");
const questInfo = document.getElementById("questInfo");

shopCloseBtn.addEventListener("click", () => {
  closeShopUI();
});

function openBuilding(id) {
  if (id === "shop") {
    openShopUI("shop");
  } else if (id === "blacksmith") {
    openShopUI("blacksmith");
  } else if (id === "stables") {
    openShopUI("stables");
  } else if (id === "temple") {
    openShopUI("temple");
  } else if (id === "searchers_lounge") {
    openShopUI("searchers_lounge");
  }
}

function openShopUI(mode) {
  shopMode = mode;
  shopGrid.innerHTML = "";
  questInfo.style.display = "none";

  if (mode === "shop") {
    shopTitle.textContent = "Troy Shop";
    const items = [
      { id: "sword", cost: 15, label: "Sword" },
      { id: "axe", cost: 15, label: "Axe" },
      { id: "bow", cost: 15, label: "Bow" },
      { id: "spear", cost: 17, label: "Spear" },
      { id: "shield_item", cost: 20, label: "Shield" },
      { id: "chariot_normal", cost: 25, label: "Chariot" },
      { id: "potion_strength", cost: 7, label: "Str" },
      { id: "potion_swiftness", cost: 7, label: "Swift" },
      { id: "potion_fortitude", cost: 7, label: "Fort" },
      { id: "potion_aegis", cost: 7, label: "Aegis" }
    ];
    buildShopItems(items, buyShopItem);

  } else if (mode === "blacksmith") {
    shopTitle.textContent = "Blacksmith (Upgrades)";
    const items = [
      { id: "sword", cost: 12, label: "Sword +1" },
      { id: "axe", cost: 12, label: "Axe +1" },
      { id: "bow", cost: 12, label: "Bow +1" },
      { id: "spear", cost: 14, label: "Spear +1" },
      { id: "shield_item", cost: 17, label: "Shield +" },
      { id: "chariot_normal", cost: 22, label: "Chariot +" }
    ];
    buildShopItems(items, upgradeItem);

  } else if (mode === "stables") {
    shopTitle.textContent = "Stables";
    const items = [
      { id: "mount_lion", cost: 20, label: "Lion" },
      { id: "mount_pegasus", cost: 20, label: "Pegasus" },
      { id: "mount_bull", cost: 20, label: "Bull" },
      { id: "mount_horse", cost: 10, label: "Horse" }
    ];
    buildShopItems(items, buyShopItem);

  } else if (mode === "temple") {
    shopTitle.textContent = "Temple";
    const items = [
      { id: "trident", cost: 35, label: "Trident" },
      { id: "lightning", cost: 35, label: "Lightning" },
      { id: "torch", cost: 35, label: "Torch" },
      { id: "artemisBow", cost: 35, label: "Artemis" },
      { id: "helmet_invisibility", cost: 35, label: "Helmet" },
      { id: "chaos_charm", cost: 35, label: "Chaos" },
      { id: "blood_charm", cost: 35, label: "Blood" },
      { id: "time_skip_charm", cost: 35, label: "Skip" },
      { id: "time_slow_charm", cost: 35, label: "Slow" },
      { id: "time_rewind_charm", cost: 35, label: "Rewind" },
      { id: "time_freeze_charm", cost: 35, label: "Freeze" }
    ];
    buildShopItems(items, buyShopItem);

  } else if (mode === "searchers_lounge") {
    shopTitle.textContent = "Searcher’s Lounge";
    questInfo.style.display = "block";
    questInfo.textContent = `Quests: ${questProgress.completed}/${questProgress.totalQuests}`;

    const items = [];
    if (questProgress.completed >= questProgress.totalQuests) {
      items.push({ id: "reward", cost: 0, label: "Claim Rewards" });
    }

    buildShopItems(items, claimSearchersRewards);
  }

  shopOverlay.style.display = "block";
}

function closeShopUI() {
  shopOverlay.style.display = "none";
  shopMode = null;
}

function buildShopItems(items, handler) {
  items.forEach(it => {
    const div = document.createElement("div");
    div.className = "shopItem";
    div.dataset.id = it.id;
    div.dataset.cost = it.cost;

    const costSpan = document.createElement("div");
    costSpan.className = "shopCost";
    costSpan.textContent = it.cost > 0 ? it.cost + " D" : "";
    div.appendChild(costSpan);

    const labelSpan = document.createElement("span");
    labelSpan.textContent = it.label;
    div.appendChild(labelSpan);

    div.addEventListener("click", () => {
      handler(it.id, it.cost);
    });

    shopGrid.appendChild(div);
  });
}

function canAfford(cost) {
  return drachma >= cost;
}

function spendDrachma(cost) {
  drachma -= cost;
  updateDrachmaHUD();
}

function buyShopItem(id, cost) {
  if (!canAfford(cost)) {
    toast("Not enough drachma!");
    return;
  }

  if (id === "shield_item") {
    weaponsOwned.shield = true;
  } else if (id === "chariot_normal") {
    // nothing special, just item
  } else if (id === "sword" || id === "axe" || id === "bow" || id === "spear" ||
             id === "trident" || id === "lightning" || id === "torch" || id === "artemisBow") {
    weaponsOwned[id] = true;
  } else if (id === "helmet_invisibility") {
    gearOwned.helmet = true;
  }

  spendDrachma(cost);
  addItemToInventory(id);
  toast("Purchased " + (itemData[id] ? itemData[id].name : id));
}

function upgradeItem(id, cost) {
  if (!canAfford(cost)) {
    toast("Not enough drachma!");
    return;
  }

  if (id === "shield_item" || id === "chariot_normal") {
    const owned = inventory.some(it => it && it.id === id);
    if (!owned) {
      toast("You must own this first.");
      return;
    }
    spendDrachma(cost);
    toast("Upgraded " + (itemData[id] ? itemData[id].name : id));
    return;
  }

  if (!weapons[id]) {
    toast("Cannot upgrade this.");
    return;
  }

  const owned = weaponsOwned[id] || inventory.some(it => it && it.id === id);
  if (!owned) {
    toast("You must own this weapon first.");
    return;
  }

  spendDrachma(cost);
  weapons[id].damage += 1;
  toast("Upgraded " + (itemData[id] ? itemData[id].name : id) + " damage!");
}

function claimSearchersRewards(id, cost) {
  if (questProgress.completed < questProgress.totalQuests) {
    toast("Complete all quests first.");
    return;
  }

  giveSearchersRewards();
  questProgress.completed = 0;
  allQuestsComplete = false;
  questInfo.textContent = `Quests: ${questProgress.completed}/${questProgress.totalQuests}`;
  shopGrid.innerHTML = "";
}

function giveSearchersRewards() {
  const pool = [
    "sword","axe","bow","spear","shield_item","trident","lightning",
    "torch","artemisBow","helmet_invisibility","chaos_charm",
    "blood_charm","time_skip_charm","time_slow_charm",
    "time_rewind_charm","time_freeze_charm",
    "mount_lion","mount_pegasus","mount_bull","mount_horse",
    "chariot_normal","chariot_helios",
    "potion_strength","potion_swiftness",
    "potion_fortitude","potion_aegis"
  ];

  const owned = new Set(inventory.filter(i => i).map(i => i.id));
  const available = pool.filter(id => !owned.has(id));

  const rewards = [];

  for (let i = 0; i < 3 && available.length > 0; i++) {
    const pick = available.splice(Math.floor(Math.random() * available.length), 1)[0];
    rewards.push(pick);
    addItemToInventory(pick);
  }

  toast("You received " + rewards.length + " rare items!");
}

/* =========================================================
   Init
   ========================================================= */
updateEquipHUD();
updateHPHUD();
updateDrachmaHUD();
requestAnimationFrame(update);
</script>
</body>
</html>
